diff --git a/build/lib/darm_gym_env/__init__.py b/build/lib/darm_gym_env/__init__.py
index 46d5fc2..4068ff9 100644
--- a/build/lib/darm_gym_env/__init__.py
+++ b/build/lib/darm_gym_env/__init__.py
@@ -1,4 +1,5 @@
 from darm_gym_env.darm_gym import DARMEnv
+from darm_gym_env.darm_render import DARMRender
 from darm_gym_env.darm_sf_gym import DARMSFEnv
 
 from gym.envs.registration import register
diff --git a/build/lib/darm_gym_env/darm_gym.py b/build/lib/darm_gym_env/darm_gym.py
index 331dae2..d034ea8 100644
--- a/build/lib/darm_gym_env/darm_gym.py
+++ b/build/lib/darm_gym_env/darm_gym.py
@@ -2,39 +2,43 @@ import os
 import numpy as np
 import collections
 
+import darm_gym_env.darm_render
 import gym
 import mujoco as mj
-from mujoco.glfw import glfw
 
 from pathlib import Path
 
 
 DARM_XML_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/mujoco_env/darm.xml"
-SF_START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/DARMHand_SF_start_state.npy"
-MF_START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/DARMHand_MFNW_start_state.npy"
+START_STATE_FILE_DIR = Path(f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/start_states")
 
 class DARMEnv(gym.Env):
     metadata = {"render_modes": ["human"], "render_fps": 60}
 
     def __init__(self, render_mode=None, action_time=0.08, hand_name="hand1",
-                min_th = 0.004,
-                min_target_th = 2*0.004,
-                max_target_th = 5*0.004, # 20 mm
+                min_th = 0.4,
+                angle_min_th = 10, # degrees
+                min_target_th = 0.8,
+                max_target_th = 2.0,
+                distance_metres_scale = 100,
                 target_joint_state_delta = [],
                 min_joint_vals = [],
                 max_joint_vals = [],
                 max_tendon_tension = [],
-                single_finger_env = False,
-                ignore_load_start_states = False
+                start_state_file = "DARMHand_MFNW_start_state.npy",
+                ignore_load_start_states = False,
+                digits = ["i", "ii", "iii", "iv", "v"]
                 ) -> None:
         super().__init__()
         assert render_mode is None or render_mode in self.metadata["render_modes"]
         
+        # ========================== Others ==========================
+        self.distance_scale = distance_metres_scale # scaling factor for distance measurements from meteres
 
         # ========================== Env Parameters ==========================
         self.render_mode = render_mode
         self.hand_name = hand_name
-        self.single_finger_env = single_finger_env
+        self.start_state_file = start_state_file
         self.action_time = action_time
         self.ep_start_time = 0  # episode start time
 
@@ -43,16 +47,12 @@ class DARMEnv(gym.Env):
         self._load_model()
         if not (self.model and self.data):
             raise "Error loading model"
-        self._get_fingertip_indices()
         
 
         # ========================== Setup Rendering ==========================
-        self.renderer = mj.Renderer(self.model)
-        # enable joint visualization option:
-        self.scene_option = mj.MjvOption()
-        self.scene_option.flags[mj.mjtVisFlag.mjVIS_JOINT] = True
-        self.last_frame = self.renderer.render()
-        self.last_frame_time = 0
+        if self.render_mode == "human":
+            self.darm_render = darm_gym_env.darm_render.DARMRender(self.model, self.data, (1200,900))
+            self.darm_render.init_window_render()
 
 
         # ========================== Load targets ==========================
@@ -71,17 +71,20 @@ class DARMEnv(gym.Env):
         self.max_joint_vals = self.max_joint_vals*(np.pi/180)
         self.target_joint_state_delta = self.target_joint_state_delta*(np.pi/180)
 
-        self.min_th = min_th    # norm threshold in metres at which env is solved
-        self.min_target_th = min_target_th  # min norm to target state
-        self.max_target_th = max_target_th  # max norm to target state
+        self.min_th = min_th   # norm threshold in metres at which env is solved
+        self.angle_min_th = np.radians(angle_min_th)
+        self.min_target_th = min_target_th # min norm to target state
+        self.max_target_th = max_target_th # max norm to target state
 
         # Initialize target observation
-        self.target_obs = np.zeros(3*len(self.fingertip_indices))
+        self.target_obs = np.zeros((5,7))
+        self.prev_fingertip_pose = np.zeros((5,7))
 
 
         # ========================== Reward Components Weights ==========================
         self.rwd_keys_wt = dict(
             reach = 1.0,
+            contact = 1.0,
             bonus = 4.0,
             penalty = 50,
             act_reg = 0.01,
@@ -95,13 +98,19 @@ class DARMEnv(gym.Env):
         # Reference Position is at the centre of the wrist
         # The ref pos will remain fixed since it was taken before simulation started
         mj.mj_forward(self.model, self.data)
-        ref_body_idx = mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_BODY), f"{self.hand_name}_rc_centre_block")
-        self.ref_pos = np.array(self.data.xpos[ref_body_idx])
+        self.ref_pos = self.data.body(f"{self.hand_name}_rc_centre_block").xpos
+
+        # ========================== Others ==========================
+        self.index_str_mapping = {"i":0, "ii":1, "iii":2, "iv":3, "v":4}
+        self.index_int_mapping = {0:"i", 1:"ii", 2:"iii", 3:"iv", 4:"v"}
+        self.all_digits = ["i", "ii", "iii", "iv", "v"]
+        self.digits = digits
+        self.digits_indices = np.array([self.index_str_mapping[idx_str] for idx_str in self.digits])
 
 
         # ========================== Define Observation and Action Space ==========================
         self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, 
-                                                shape=(3*3*len(self.fingertip_indices),), 
+                                                shape=(len(self._get_obs()),), 
                                                 dtype=np.float32)
         
 
@@ -112,11 +121,6 @@ class DARMEnv(gym.Env):
                                             high=np.array([1.0]*self.model.nu), 
                                             shape=(self.model.nu,), dtype=np.float32)
 
-
-        # ========================== For Human Rendering ==========================
-        self.window = None
-        self.window_size = 1200, 900
-
     def _load_model(self):
         xml_path = DARM_XML_FILE
         self.model = mj.MjModel.from_xml_path(xml_path)
@@ -128,13 +132,9 @@ class DARMEnv(gym.Env):
             return
         
         self.data = mj.MjData(self.model)
-        renderer = mj.Renderer(self.model)
 
     def _load_start_states(self):
-        if self.single_finger_env:
-            filename = SF_START_STATE_FILE
-        else:
-            filename = MF_START_STATE_FILE
+        filename = START_STATE_FILE_DIR/self.start_state_file
 
         with open(filename, 'rb') as f:
             self.start_states = np.load(f, allow_pickle=True)
@@ -173,44 +173,160 @@ class DARMEnv(gym.Env):
 
     def _controller_cb(self, model, data):
         pass
-
-    def _get_fingertip_indices(self):
-        # NOTE: Remember to set the mocap index properly in reset()
-        if self.single_finger_env:
-            indices = ["ii"]
+    
+    def transform_distance_obs(self, obs):
+        """
+        - Transforms the distance to be in the frame of the wrist (RC Joint)
+        - Convert the distance reading to cm
+        """
+        return (obs - self.ref_pos)*self.distance_scale
+    
+    def remove_distance_obs_transform(self, obs):
+        """Removes the transformation applied to distance observations"""
+        return (obs/self.distance_scale) + self.ref_pos
+
+    def get_finger_frames_pos(self, idx_str):
+        # get Proximal Phalanx frame
+        def pp_frame():
+            # BODY: ${hand_name}_proximal_phalanx_${index}
+            frame_pos = self.data.body(f"{self.hand_name}_proximal_phalanx_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+            
+        # get Middle Phalanx frame
+        def mp_frame():
+            # BODY: ${hand_name}_middle_phalanx_${index} [ii to v]
+            frame_pos = self.data.body(f"{self.hand_name}_middle_phalanx_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+
+        # get Distal Phalanx frame
+        def dp_frame():
+            # BODY: ${hand_name}_distal_phalanx_${index}
+            frame_pos = self.data.body(f"{self.hand_name}_distal_phalanx_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+
+        # get fingertip frame
+        def fingertip_frame():
+            # SITE: ${hand_name}_fingertip_${index}
+            frame_pos = self.data.site(f"{self.hand_name}_fingertip_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+
+        if idx_str == "i":
+            return np.concatenate((pp_frame(), dp_frame(),
+                                   fingertip_frame()))
         else:
-            indices = ["i", "ii", "iii", "iv", "v"]
+            return np.concatenate((pp_frame(), mp_frame(),
+                                   dp_frame(), fingertip_frame()))
 
-        self.fingertip_indices = [mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_SITE), f"{self.hand_name}_fingertip_{i}") for i in indices]
-    
-    def _get_obs(self, prev_obs, new_obs, action_time=None):
-        if not action_time:
-            # if no action time velocity is zero. i.e. after reset
-            vel_obs = np.zeros((3*len(self.fingertip_indices),))
-        elif action_time: 
-            prev_fingertip_pos = prev_obs[:3*len(self.fingertip_indices)]
-            new_fingertip_pos = new_obs[:3*len(self.fingertip_indices)]
+    def get_fingertip_pose(self, idx_str):
+        """Returns the position and orientation of the fingertip `idx_str`"""
+
+        fingertip_pos = self.data.site(f"{self.hand_name}_fingertip_{idx_str}").xpos
+        fingertip_pos = self.transform_distance_obs(fingertip_pos)
+
+        fingertip_orient = self.data.body(f"{self.hand_name}_distal_phalanx_{idx_str}").xquat
+
+        return np.concatenate((fingertip_pos, fingertip_orient))        
+
+    def get_finger_contacts(self, index):
+        contact_geoms1 = self.data.contact.geom1
+        contact_geoms2 = self.data.contact.geom2
+
+        colliding_digits = []
+        colliding_with_palm = False
+
+        def get_digit_str(name):
+            if name.endswith("_i"): return "i"
+            if name.endswith("_ii"): return "ii"
+            if name.endswith("_iii"): return "iii"
+            if name.endswith("_iv"): return "iv"
+            if name.endswith("_v"): return "v"
+            
+            return None
+
+        def filter_contacts(contacts1, contacts2):
+            for idx in range(len(contacts1)):
+                geom_idx = contacts1[idx]
+                # Ignore Wraps
+                if "_wrap" in self.model.geom(geom_idx).name:
+                    continue
+                
+                # Get the Body name
+                bodyid = self.model.geom(geom_idx).bodyid[0]
+                bodyname = self.model.body(bodyid).name
+
+                # If body is in current phalanges group
+                if bodyname.endswith(f"_phalanx_{self.index_int_mapping[index]}"):
+                    coll_geom_idx = contacts2[idx]
+                    # Ignore Wraps
+                    if "_wrap" in self.model.geom(coll_geom_idx).name:
+                        continue
+
+                    # Get the body collided with
+                    coll_bodyid = self.model.geom(coll_geom_idx).bodyid[0]
+                    coll_bodyname = self.model.body(coll_bodyid).name
+
+                    if coll_bodyname == "hand1_carpals_metacarpals":
+                        nonlocal colliding_with_palm
+                        colliding_with_palm = True
+
+                    digit = get_digit_str(coll_bodyname)
+                    if digit and (digit != self.index_int_mapping[index]):
+                        colliding_digits.append(digit)
+
+        filter_contacts(contact_geoms1, contact_geoms2)
+        filter_contacts(contact_geoms2, contact_geoms1)
+
+        collision_obs = np.zeros(6)
+        if colliding_with_palm: collision_obs[0] = 1
+        for idx_str in colliding_digits:
+            collision_obs[self.index_str_mapping[idx_str]+1] = 1
+
+        return collision_obs
+
+    def digits_in_contact(self):
+        """Returns True if there is any collision between the digits of the hand"""
+        contacts = np.concatenate([self.get_finger_contacts(index) for index in self.digits_indices])
+        return sum(contacts) > 0
+
+    def _get_obs(self, action_time=None):
+        def get_target_pose(index):
+            return self.target_obs[index]
+
+        def get_kinematic_chain_obs(index):
+            return self.get_finger_frames_pos(self.index_int_mapping[index])
+
+        def get_vel_obs(index):
+            if not action_time:
+                # if no action time, velocity is zero. i.e. after reset
+                return np.zeros(3)
+            
+            prev_fingertip_pos = self.prev_fingertip_pose[index][:3]
+            new_fingertip_pos = self.get_fingertip_pose(self.index_int_mapping[index])[:3]
             vel_obs = (new_fingertip_pos - prev_fingertip_pos)/action_time
+            return vel_obs
+
+        def get_contact_obs(index):
+            return self.get_finger_contacts(index)
 
-        return np.concatenate((np.array([(np.array(self.data.site_xpos[i]) - self.ref_pos) for i in self.fingertip_indices]).flatten(),
-                             self.target_obs,
-                             vel_obs))
+        def get_finger_obs(index):
+            return np.concatenate((get_target_pose(index),
+                            get_kinematic_chain_obs(index),
+                            get_vel_obs(index),
+                            get_contact_obs(index)))
+            
+        obs = np.concatenate([get_finger_obs(index) for index in self.digits_indices])
+        return obs
 
     def _get_info(self):
         return {"sim_time": self.data.time - self.ep_start_time}
 
-    def _norm_to_target(self, obs):
-        """
-        Returns the norm of each fingertip to the target position
-        obs: an observation from the observation space [...fingertip_pos, ...target_pos, ...fingertip_vel]
-        """
-        obs = obs.reshape((-1, 3))
-        n_fingertips = len(self.fingertip_indices)
+    def position_norm(self, pos1, pos2):
+        """Returns the distance between two position vectors"""
+        return np.linalg.norm(pos1-pos2, ord=2, axis=-1)
 
-        fingertip_poses = obs[0:n_fingertips]
-        target_poses = obs[n_fingertips:2*n_fingertips]
-
-        return np.linalg.norm(fingertip_poses-target_poses, ord=2, axis=-1)
+    def orientation_norm(self, quat1, quat2):
+        """Returns the angular distance between two quaternion orientation"""
+        return 2*np.arccos(np.abs(np.dot(quat1, np.transpose(quat2)).diagonal()))
 
     def _get_reward(self, action, new_state):
         """
@@ -224,10 +340,20 @@ class DARMEnv(gym.Env):
         Agent is rewarded for coming close to the target beyond a threshold 
         """
 
-        reach_dist = self._norm_to_target(new_state)    # NOTE: Single finger
         near_th = self.min_th
+        angle_near_th = self.angle_min_th
         far_th = 2*self.max_target_th
 
+        fingertip_obs = np.zeros_like(self.target_obs)
+        for idx_str in self.digits:
+            fingertip_obs[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
+        reach_dist_all = self.position_norm(fingertip_obs[:, :3], self.target_obs[:, :3])
+        angle_dist_all = self.orientation_norm(fingertip_obs[:, 3:7], self.target_obs[:, 3:7])
+        # Compute reward only for active digits
+        reach_dist = reach_dist_all[self.digits_indices]
+        angle_dist = angle_dist_all[self.digits_indices]
+        contact = np.array([sum(self.get_finger_contacts(i)) for i in self.digits_indices])
+
         # Scale action down to [0, 1] from [0, max_tendon_tension]
         action = action / self.max_tendon_tension
         
@@ -235,14 +361,19 @@ class DARMEnv(gym.Env):
         # act_mag = np.linalg.norm(action.reshape(-1, 5)) # reshape action to (-1,5), ensure nu is ordered from mujoco
         # TODO: Consider scaling down this act_mag to be equiv. to a single finger with nu=5
         act_mag = np.linalg.norm(action)/np.sqrt(self.model.nu/1) # action magnitude is not measured per finger but as a whole
-        act_mag = np.array([act_mag]*len(self.fingertip_indices))
+        act_mag = np.array([act_mag]*len(self.digits))
         # by dividing by sqrt(nu/5), the norm is similar to when computing with nu==5. Check it out.
         # by dividing by sqrt(nu) act_mag will have a max value in the order of the max_value of action now => 1
         
+        # reach dist scaled from cm to m
+        reach_rwd = -1*0.01*reach_dist - 0.05*angle_dist
+        bonus_rwd = (1.*(np.logical_and((reach_dist<2*near_th), (angle_dist<2*angle_near_th))) + 
+                 1.*(np.logical_and((reach_dist<near_th), (angle_dist<angle_near_th))))
         rwd_dict = collections.OrderedDict((
             # Optional Keys
-            ('reach',   -1.*reach_dist),
-            ('bonus',   1.*(reach_dist<2*near_th) + 1.*(reach_dist<near_th)),
+            ('reach',   reach_rwd),
+            ('bonus',   bonus_rwd),
+            ('contact', -1*contact),
             ('act_reg', -1.*act_mag),
             ('penalty', -1.*(reach_dist>far_th)),
             # Must keys
@@ -253,19 +384,13 @@ class DARMEnv(gym.Env):
 
             # Weights:
             # reach = 1.0,
+            # contact = 1.0
             # bonus = 4.0,
             # penalty = 50,
             # act_reg = 0.1,
         rwd_dict['dense'] = np.sum([wt*rwd_dict[key] for key, wt in self.rwd_keys_wt.items()], axis=0)
         return rwd_dict
 
-    def _get_done(self, new_state):
-        return all(self._norm_to_target(new_state) < self.min_th)
-
-    def _check_collision(self):
-        """Returns True if there is collision, otherwise False"""
-        return len(self.data.contact.geom1) > 0
-
     def generate_start_state(self):
         while True:
             # ========================== Sample valid start_state from Joint Space ==========================
@@ -275,7 +400,7 @@ class DARMEnv(gym.Env):
             # joint_state = self.min_joint_vals + normal_sampling*(self.max_joint_vals - self.min_joint_vals)
             self.forward(joint_state)
 
-            if self._check_collision(): # returns True if there is collision
+            if self.digits_in_contact(): # returns True if there is collision between fingers
                 # ensure there is no collision at the start state
                 continue
             
@@ -285,21 +410,28 @@ class DARMEnv(gym.Env):
             target_joint_state = np.clip(a=joint_state + joint_state_delta, 
                                         a_min=self.min_joint_vals, 
                                         a_max=self.max_joint_vals)
-            self.target_obs = self.forward(target_joint_state)[:3*len(self.fingertip_indices)]
-            if self._check_collision(): # returns True if there is collision
+            self.forward(target_joint_state)
+            if self.digits_in_contact(): # returns True if there is collision
                 # ensure there is no collision at the target state
                 continue
             
+            for idx_str in self.digits:
+                self.target_obs[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
+            
             # Return to start state
             observation = self.forward(joint_state)
 
             # Verify distance of start state to target state is within limits
-            norm = self._norm_to_target(observation)
+            fingertip_obs = np.zeros_like(self.target_obs)
+            for idx_str in self.digits:
+                fingertip_obs[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
+            norm_all = self.position_norm(fingertip_obs[:, :3], self.target_obs[:, :3])
+            norm = norm_all[self.digits_indices]
             if not (all(norm >= self.min_target_th) and all(norm <= self.max_target_th)):
                 continue
             
             # If all checks are positive, break random search loop
-            return observation, joint_state, self.target_obs      
+            return observation, joint_state, self.target_obs.copy()      
 
     def sample_saved_start_states(self):
         # Sample a start state from saved start states
@@ -315,17 +447,20 @@ class DARMEnv(gym.Env):
         # Return Observation
         return observation
 
-    # def reset(self, seed=None, options=None):
-        # super().reset()
     def reset(self, **kwargs):
         # ========================== Get a random valid pose and target ==========================
         # observation, _, _ = self.generate_start_state()
         observation = self.sample_saved_start_states()
+        
+        for idx_str in self.digits:
+            self.prev_fingertip_pose[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
 
         # ========================== Render Frame ==========================
         if self.render_mode == "human":
-            # Update target visualization mocaps pos
-            self.data.mocap_pos = self.target_obs.reshape(len(self.fingertip_indices),3) + self.ref_pos
+            # Update target visualization mocaps pos and quat
+            target_pos = self.target_obs[self.digits_indices, :3]
+            self.data.mocap_pos = self.remove_distance_obs_transform(target_pos)
+            self.data.mocap_quat = self.target_obs[self.digits_indices, 3:]
             # Go Forward
             mj.mj_forward(self.model, self.data)
             self._render_frame()
@@ -334,7 +469,8 @@ class DARMEnv(gym.Env):
         return observation
 
     def step(self, action):
-        prev_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)
+        for idx_str in self.digits:
+            self.prev_fingertip_pose[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
 
         # action from model is in the range [-1,1]
         # action + 1 === [0, 2]
@@ -350,138 +486,45 @@ class DARMEnv(gym.Env):
         time_after = self.data.time # time after performing action
 
 
-        # Get new observation (fingertips_pos)
-        new_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)
-        # include velocity in new obs
-        new_obs = self._get_obs(prev_obs=prev_obs,
-                                new_obs=new_obs, 
-                                action_time=time_after-time_prev)
+        # Get observation
+        obs = self._get_obs(action_time=time_after-time_prev)
 
         if self.render_mode == "human":
             self._render_frame()
 
         # Get Reward
-        rwd_dict = self._get_reward(action, new_obs)
+        rwd_dict = self._get_reward(action, obs)
         reward = rwd_dict["dense"].mean()
         done = any(rwd_dict["done"])  # all(rwd_dict["done"])
         
-        return new_obs, reward, done, {**self._get_info(), "action": action, "reward": {**rwd_dict}}
+        return obs, reward, done, {**self._get_info(), "action": action, "reward": {**rwd_dict}}
 
     def forward(self, joint_conf):
         self.data.qpos = joint_conf
         mj.mj_forward(self.model, self.data)
-        return self._get_obs(prev_obs=None, new_obs=None, action_time=None)
+        return self._get_obs(action_time=None)
 
-    def render(self, mode, **kwargs):
-        if self.render_mode == "human":
+    def render(self, mode="human", **kwargs):
+        if mode=="human" and self.render_mode == "human":
             return self._render_frame()
-        else:
-            T = 1/DARMEnv.metadata["render_fps"]    # period
-            if (self.data.time - self.last_frame_time) >= T:
-                self.renderer.update_scene(self.data, scene_option=self.scene_option)
-                self.last_frame = self.renderer.render()
-            return self.last_frame.copy()
+        # else:
+        #     T = 1/DARMEnv.metadata["render_fps"]    # period
+        #     if (self.data.time - self.last_frame_time) >= T:
+        #         self.renderer.update_scene(self.data, scene_option=self.scene_option)
+        #         self.last_frame = self.renderer.render()
+        #     return self.last_frame.copy()
 
     def _render_frame(self):
-        if self.render_mode == "human" and not self.window:
-            # Init GLFW, create window, make OpenGL context current, request v-sync
-            glfw.init()
-            self.window = glfw.create_window(self.window_size[0], self.window_size[1], "DARM", None, None)
-            glfw.make_context_current(self.window)
-            glfw.swap_interval(1)
-
-            # Visualization
-            self.cam = mj.MjvCamera()    # abstract camera
-            self.opt = mj.MjvOption()    # visualization options
-            mj.mjv_defaultCamera(self.cam)
-            mj.mjv_defaultOption(self.opt)
-            self.scene = mj.MjvScene(self.model, maxgeom=10000)
-            self.context = mj.MjrContext(self.model, mj.mjtFontScale.mjFONTSCALE_150.value)
-
-            self.cam.azimuth = 110
-            self.cam.elevation = -24
-            self.cam.distance = 0.36
-            self.cam.lookat = np.array([0.006, -0.004,  0.215])
-
-            # For callback functions TODO:
-            self.window_button_left = False
-            self.window_button_middle = False
-            self.window_button_right = False
-            self.window_lastx = 0
-            self.window_lasty = 0
-
-            def mouse_button(window, button, act, mods):
-                # update button state
-                self.window_button_left = (glfw.get_mouse_button(
-                    window, glfw.MOUSE_BUTTON_LEFT) == glfw.PRESS)
-                self.window_button_middle = (glfw.get_mouse_button(
-                    window, glfw.MOUSE_BUTTON_MIDDLE) == glfw.PRESS)
-                self.window_button_right = (glfw.get_mouse_button(
-                    window, glfw.MOUSE_BUTTON_RIGHT) == glfw.PRESS)
-
-                # update mouse position
-                glfw.get_cursor_pos(window) # TODO: Why is this needed again
-
-            def mouse_move(window, xpos, ypos):
-                # compute mouse displacement, save
-                dx = xpos - self.window_lastx
-                dy = ypos - self.window_lasty
-                self.window_lastx = xpos
-                self.window_lasty = ypos
-
-                # no buttons down: nothing to do
-                if (not self.window_button_left) and (not self.window_button_middle) and (not self.window_button_right):
-                    return
-
-                # get current window size
-                width, height = glfw.get_window_size(window)
-
-                # get shift key state
-                PRESS_LEFT_SHIFT = glfw.get_key(
-                    window, glfw.KEY_LEFT_SHIFT) == glfw.PRESS
-                PRESS_RIGHT_SHIFT = glfw.get_key(
-                    window, glfw.KEY_RIGHT_SHIFT) == glfw.PRESS
-                mod_shift = (PRESS_LEFT_SHIFT or PRESS_RIGHT_SHIFT)
-
-                # determine action based on mouse button
-                if self.window_button_right:
-                    if mod_shift:
-                        action = mj.mjtMouse.mjMOUSE_MOVE_H
-                    else:
-                        action = mj.mjtMouse.mjMOUSE_MOVE_V
-                elif self.window_button_left:
-                    if mod_shift:
-                        action = mj.mjtMouse.mjMOUSE_ROTATE_H
-                    else:
-                        action = mj.mjtMouse.mjMOUSE_ROTATE_V
-                else:
-                    action = mj.mjtMouse.mjMOUSE_ZOOM
-
-                mj.mjv_moveCamera(self.model, action, dx/width,
-                                dy/height, self.scene, self.cam)    # TODO: Look into this, height/width issue
-
-            def scroll(window, xoffset, yoffset):
-                action = mj.mjtMouse.mjMOUSE_ZOOM
-                mj.mjv_moveCamera(self.model, action, 0.0, -0.05 *
-                                yoffset, self.scene, self.cam)
-
-            glfw.set_cursor_pos_callback(self.window, mouse_move)
-            glfw.set_mouse_button_callback(self.window, mouse_button)
-            glfw.set_scroll_callback(self.window, scroll)
-        
-        # Get Framebuffer Viewport
-        vp_width, vp_height = glfw.get_framebuffer_size(self.window)
-        viewport = mj.MjrRect(0, 0, vp_width, vp_height)
+        self.darm_render.window_render()
 
-        # Update scene and render
-        mj.mjv_updateScene(self.model, self.data, self.opt, None, self.cam, mj.mjtCatBit.mjCAT_ALL.value, self.scene)
-        mj.mjr_render(viewport, self.scene, self.context)
-
-        # swap OpenGL buffers (blocking call due to v-sync)
-        glfw.swap_buffers(self.window)
+    def close(self):
+        if self.render_mode == "human":
+            self.darm_render.close_window()
 
-        # process pending GUI events, call GLFW callbacks
-        glfw.poll_events()
 
-    def close(self):
-        glfw.terminate()
\ No newline at end of file
+if __name__ == "__main__":
+    env = DARMEnv(render_mode="human")
+    env.reset()
+    while True:
+        env.render(mode="human")
+        
\ No newline at end of file
diff --git a/darm_gym_env.egg-info/SOURCES.txt b/darm_gym_env.egg-info/SOURCES.txt
index a0b6525..fce4add 100644
--- a/darm_gym_env.egg-info/SOURCES.txt
+++ b/darm_gym_env.egg-info/SOURCES.txt
@@ -3,6 +3,7 @@ setup.py
 darm_gym_env/DARMHand-v0_test.py
 darm_gym_env/__init__.py
 darm_gym_env/darm_gym.py
+darm_gym_env/darm_render.py
 darm_gym_env/darm_sf_gym.py
 darm_gym_env/generate_DARMHand_start_state.py
 darm_gym_env/obs_DARMSFHand-v0_test.py
diff --git a/darm_gym_env.egg-info/requires.txt b/darm_gym_env.egg-info/requires.txt
index 87fb468..749b61f 100644
--- a/darm_gym_env.egg-info/requires.txt
+++ b/darm_gym_env.egg-info/requires.txt
@@ -1,2 +1,2 @@
-mujoco==2.3.2
+mujoco==2.3.3
 gym==0.21.0
diff --git a/darm_gym_env/DARMHand-v0_test.py b/darm_gym_env/DARMHand-v0_test.py
index 98ec6ef..b2df065 100644
--- a/darm_gym_env/DARMHand-v0_test.py
+++ b/darm_gym_env/DARMHand-v0_test.py
@@ -1,10 +1,13 @@
 import gym
-from darm_gym_env import DARMEnv
+# from darm_gym_env import DARMEnv
+from darm_gym import DARMEnv
 import time
 from pprint import pprint
 
-env = gym.make("darm/DarmHand-v0", render_mode="human", hand_name="hand1",
-               single_finger_env=True)
+# env = gym.make("darm/DarmHand-v0", render_mode="human", hand_name="hand1")
+env = DARMEnv(render_mode="human", hand_name="hand1", 
+              digits=["ii"], start_state_file="DARMHand_SF_start_state.npy")
+env = gym.wrappers.TimeLimit(env, max_episode_steps=200)
 
 done = False
 obs = env.reset()
diff --git a/darm_gym_env/DARMHand_MFNW_start_state.npy b/darm_gym_env/DARMHand_MFNW_start_state.npy
deleted file mode 100644
index 084f3d3..0000000
Binary files a/darm_gym_env/DARMHand_MFNW_start_state.npy and /dev/null differ
diff --git a/darm_gym_env/DARMHand_SF_start_state.npy b/darm_gym_env/DARMHand_SF_start_state.npy
deleted file mode 100644
index faabcf6..0000000
Binary files a/darm_gym_env/DARMHand_SF_start_state.npy and /dev/null differ
diff --git a/darm_gym_env/__init__.py b/darm_gym_env/__init__.py
index 46d5fc2..4068ff9 100644
--- a/darm_gym_env/__init__.py
+++ b/darm_gym_env/__init__.py
@@ -1,4 +1,5 @@
 from darm_gym_env.darm_gym import DARMEnv
+from darm_gym_env.darm_render import DARMRender
 from darm_gym_env.darm_sf_gym import DARMSFEnv
 
 from gym.envs.registration import register
diff --git a/darm_gym_env/__pycache__/__init__.cpython-38.pyc b/darm_gym_env/__pycache__/__init__.cpython-38.pyc
index 0697257..2b95bd1 100644
Binary files a/darm_gym_env/__pycache__/__init__.cpython-38.pyc and b/darm_gym_env/__pycache__/__init__.cpython-38.pyc differ
diff --git a/darm_gym_env/__pycache__/darm_gym.cpython-38.pyc b/darm_gym_env/__pycache__/darm_gym.cpython-38.pyc
index 48f6140..1b68e91 100644
Binary files a/darm_gym_env/__pycache__/darm_gym.cpython-38.pyc and b/darm_gym_env/__pycache__/darm_gym.cpython-38.pyc differ
diff --git a/darm_gym_env/darm_gym.py b/darm_gym_env/darm_gym.py
index 331dae2..d034ea8 100644
--- a/darm_gym_env/darm_gym.py
+++ b/darm_gym_env/darm_gym.py
@@ -2,39 +2,43 @@ import os
 import numpy as np
 import collections
 
+import darm_gym_env.darm_render
 import gym
 import mujoco as mj
-from mujoco.glfw import glfw
 
 from pathlib import Path
 
 
 DARM_XML_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/mujoco_env/darm.xml"
-SF_START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/DARMHand_SF_start_state.npy"
-MF_START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/DARMHand_MFNW_start_state.npy"
+START_STATE_FILE_DIR = Path(f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/start_states")
 
 class DARMEnv(gym.Env):
     metadata = {"render_modes": ["human"], "render_fps": 60}
 
     def __init__(self, render_mode=None, action_time=0.08, hand_name="hand1",
-                min_th = 0.004,
-                min_target_th = 2*0.004,
-                max_target_th = 5*0.004, # 20 mm
+                min_th = 0.4,
+                angle_min_th = 10, # degrees
+                min_target_th = 0.8,
+                max_target_th = 2.0,
+                distance_metres_scale = 100,
                 target_joint_state_delta = [],
                 min_joint_vals = [],
                 max_joint_vals = [],
                 max_tendon_tension = [],
-                single_finger_env = False,
-                ignore_load_start_states = False
+                start_state_file = "DARMHand_MFNW_start_state.npy",
+                ignore_load_start_states = False,
+                digits = ["i", "ii", "iii", "iv", "v"]
                 ) -> None:
         super().__init__()
         assert render_mode is None or render_mode in self.metadata["render_modes"]
         
+        # ========================== Others ==========================
+        self.distance_scale = distance_metres_scale # scaling factor for distance measurements from meteres
 
         # ========================== Env Parameters ==========================
         self.render_mode = render_mode
         self.hand_name = hand_name
-        self.single_finger_env = single_finger_env
+        self.start_state_file = start_state_file
         self.action_time = action_time
         self.ep_start_time = 0  # episode start time
 
@@ -43,16 +47,12 @@ class DARMEnv(gym.Env):
         self._load_model()
         if not (self.model and self.data):
             raise "Error loading model"
-        self._get_fingertip_indices()
         
 
         # ========================== Setup Rendering ==========================
-        self.renderer = mj.Renderer(self.model)
-        # enable joint visualization option:
-        self.scene_option = mj.MjvOption()
-        self.scene_option.flags[mj.mjtVisFlag.mjVIS_JOINT] = True
-        self.last_frame = self.renderer.render()
-        self.last_frame_time = 0
+        if self.render_mode == "human":
+            self.darm_render = darm_gym_env.darm_render.DARMRender(self.model, self.data, (1200,900))
+            self.darm_render.init_window_render()
 
 
         # ========================== Load targets ==========================
@@ -71,17 +71,20 @@ class DARMEnv(gym.Env):
         self.max_joint_vals = self.max_joint_vals*(np.pi/180)
         self.target_joint_state_delta = self.target_joint_state_delta*(np.pi/180)
 
-        self.min_th = min_th    # norm threshold in metres at which env is solved
-        self.min_target_th = min_target_th  # min norm to target state
-        self.max_target_th = max_target_th  # max norm to target state
+        self.min_th = min_th   # norm threshold in metres at which env is solved
+        self.angle_min_th = np.radians(angle_min_th)
+        self.min_target_th = min_target_th # min norm to target state
+        self.max_target_th = max_target_th # max norm to target state
 
         # Initialize target observation
-        self.target_obs = np.zeros(3*len(self.fingertip_indices))
+        self.target_obs = np.zeros((5,7))
+        self.prev_fingertip_pose = np.zeros((5,7))
 
 
         # ========================== Reward Components Weights ==========================
         self.rwd_keys_wt = dict(
             reach = 1.0,
+            contact = 1.0,
             bonus = 4.0,
             penalty = 50,
             act_reg = 0.01,
@@ -95,13 +98,19 @@ class DARMEnv(gym.Env):
         # Reference Position is at the centre of the wrist
         # The ref pos will remain fixed since it was taken before simulation started
         mj.mj_forward(self.model, self.data)
-        ref_body_idx = mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_BODY), f"{self.hand_name}_rc_centre_block")
-        self.ref_pos = np.array(self.data.xpos[ref_body_idx])
+        self.ref_pos = self.data.body(f"{self.hand_name}_rc_centre_block").xpos
+
+        # ========================== Others ==========================
+        self.index_str_mapping = {"i":0, "ii":1, "iii":2, "iv":3, "v":4}
+        self.index_int_mapping = {0:"i", 1:"ii", 2:"iii", 3:"iv", 4:"v"}
+        self.all_digits = ["i", "ii", "iii", "iv", "v"]
+        self.digits = digits
+        self.digits_indices = np.array([self.index_str_mapping[idx_str] for idx_str in self.digits])
 
 
         # ========================== Define Observation and Action Space ==========================
         self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, 
-                                                shape=(3*3*len(self.fingertip_indices),), 
+                                                shape=(len(self._get_obs()),), 
                                                 dtype=np.float32)
         
 
@@ -112,11 +121,6 @@ class DARMEnv(gym.Env):
                                             high=np.array([1.0]*self.model.nu), 
                                             shape=(self.model.nu,), dtype=np.float32)
 
-
-        # ========================== For Human Rendering ==========================
-        self.window = None
-        self.window_size = 1200, 900
-
     def _load_model(self):
         xml_path = DARM_XML_FILE
         self.model = mj.MjModel.from_xml_path(xml_path)
@@ -128,13 +132,9 @@ class DARMEnv(gym.Env):
             return
         
         self.data = mj.MjData(self.model)
-        renderer = mj.Renderer(self.model)
 
     def _load_start_states(self):
-        if self.single_finger_env:
-            filename = SF_START_STATE_FILE
-        else:
-            filename = MF_START_STATE_FILE
+        filename = START_STATE_FILE_DIR/self.start_state_file
 
         with open(filename, 'rb') as f:
             self.start_states = np.load(f, allow_pickle=True)
@@ -173,44 +173,160 @@ class DARMEnv(gym.Env):
 
     def _controller_cb(self, model, data):
         pass
-
-    def _get_fingertip_indices(self):
-        # NOTE: Remember to set the mocap index properly in reset()
-        if self.single_finger_env:
-            indices = ["ii"]
+    
+    def transform_distance_obs(self, obs):
+        """
+        - Transforms the distance to be in the frame of the wrist (RC Joint)
+        - Convert the distance reading to cm
+        """
+        return (obs - self.ref_pos)*self.distance_scale
+    
+    def remove_distance_obs_transform(self, obs):
+        """Removes the transformation applied to distance observations"""
+        return (obs/self.distance_scale) + self.ref_pos
+
+    def get_finger_frames_pos(self, idx_str):
+        # get Proximal Phalanx frame
+        def pp_frame():
+            # BODY: ${hand_name}_proximal_phalanx_${index}
+            frame_pos = self.data.body(f"{self.hand_name}_proximal_phalanx_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+            
+        # get Middle Phalanx frame
+        def mp_frame():
+            # BODY: ${hand_name}_middle_phalanx_${index} [ii to v]
+            frame_pos = self.data.body(f"{self.hand_name}_middle_phalanx_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+
+        # get Distal Phalanx frame
+        def dp_frame():
+            # BODY: ${hand_name}_distal_phalanx_${index}
+            frame_pos = self.data.body(f"{self.hand_name}_distal_phalanx_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+
+        # get fingertip frame
+        def fingertip_frame():
+            # SITE: ${hand_name}_fingertip_${index}
+            frame_pos = self.data.site(f"{self.hand_name}_fingertip_{idx_str}").xpos
+            return self.transform_distance_obs(frame_pos)
+
+        if idx_str == "i":
+            return np.concatenate((pp_frame(), dp_frame(),
+                                   fingertip_frame()))
         else:
-            indices = ["i", "ii", "iii", "iv", "v"]
+            return np.concatenate((pp_frame(), mp_frame(),
+                                   dp_frame(), fingertip_frame()))
 
-        self.fingertip_indices = [mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_SITE), f"{self.hand_name}_fingertip_{i}") for i in indices]
-    
-    def _get_obs(self, prev_obs, new_obs, action_time=None):
-        if not action_time:
-            # if no action time velocity is zero. i.e. after reset
-            vel_obs = np.zeros((3*len(self.fingertip_indices),))
-        elif action_time: 
-            prev_fingertip_pos = prev_obs[:3*len(self.fingertip_indices)]
-            new_fingertip_pos = new_obs[:3*len(self.fingertip_indices)]
+    def get_fingertip_pose(self, idx_str):
+        """Returns the position and orientation of the fingertip `idx_str`"""
+
+        fingertip_pos = self.data.site(f"{self.hand_name}_fingertip_{idx_str}").xpos
+        fingertip_pos = self.transform_distance_obs(fingertip_pos)
+
+        fingertip_orient = self.data.body(f"{self.hand_name}_distal_phalanx_{idx_str}").xquat
+
+        return np.concatenate((fingertip_pos, fingertip_orient))        
+
+    def get_finger_contacts(self, index):
+        contact_geoms1 = self.data.contact.geom1
+        contact_geoms2 = self.data.contact.geom2
+
+        colliding_digits = []
+        colliding_with_palm = False
+
+        def get_digit_str(name):
+            if name.endswith("_i"): return "i"
+            if name.endswith("_ii"): return "ii"
+            if name.endswith("_iii"): return "iii"
+            if name.endswith("_iv"): return "iv"
+            if name.endswith("_v"): return "v"
+            
+            return None
+
+        def filter_contacts(contacts1, contacts2):
+            for idx in range(len(contacts1)):
+                geom_idx = contacts1[idx]
+                # Ignore Wraps
+                if "_wrap" in self.model.geom(geom_idx).name:
+                    continue
+                
+                # Get the Body name
+                bodyid = self.model.geom(geom_idx).bodyid[0]
+                bodyname = self.model.body(bodyid).name
+
+                # If body is in current phalanges group
+                if bodyname.endswith(f"_phalanx_{self.index_int_mapping[index]}"):
+                    coll_geom_idx = contacts2[idx]
+                    # Ignore Wraps
+                    if "_wrap" in self.model.geom(coll_geom_idx).name:
+                        continue
+
+                    # Get the body collided with
+                    coll_bodyid = self.model.geom(coll_geom_idx).bodyid[0]
+                    coll_bodyname = self.model.body(coll_bodyid).name
+
+                    if coll_bodyname == "hand1_carpals_metacarpals":
+                        nonlocal colliding_with_palm
+                        colliding_with_palm = True
+
+                    digit = get_digit_str(coll_bodyname)
+                    if digit and (digit != self.index_int_mapping[index]):
+                        colliding_digits.append(digit)
+
+        filter_contacts(contact_geoms1, contact_geoms2)
+        filter_contacts(contact_geoms2, contact_geoms1)
+
+        collision_obs = np.zeros(6)
+        if colliding_with_palm: collision_obs[0] = 1
+        for idx_str in colliding_digits:
+            collision_obs[self.index_str_mapping[idx_str]+1] = 1
+
+        return collision_obs
+
+    def digits_in_contact(self):
+        """Returns True if there is any collision between the digits of the hand"""
+        contacts = np.concatenate([self.get_finger_contacts(index) for index in self.digits_indices])
+        return sum(contacts) > 0
+
+    def _get_obs(self, action_time=None):
+        def get_target_pose(index):
+            return self.target_obs[index]
+
+        def get_kinematic_chain_obs(index):
+            return self.get_finger_frames_pos(self.index_int_mapping[index])
+
+        def get_vel_obs(index):
+            if not action_time:
+                # if no action time, velocity is zero. i.e. after reset
+                return np.zeros(3)
+            
+            prev_fingertip_pos = self.prev_fingertip_pose[index][:3]
+            new_fingertip_pos = self.get_fingertip_pose(self.index_int_mapping[index])[:3]
             vel_obs = (new_fingertip_pos - prev_fingertip_pos)/action_time
+            return vel_obs
+
+        def get_contact_obs(index):
+            return self.get_finger_contacts(index)
 
-        return np.concatenate((np.array([(np.array(self.data.site_xpos[i]) - self.ref_pos) for i in self.fingertip_indices]).flatten(),
-                             self.target_obs,
-                             vel_obs))
+        def get_finger_obs(index):
+            return np.concatenate((get_target_pose(index),
+                            get_kinematic_chain_obs(index),
+                            get_vel_obs(index),
+                            get_contact_obs(index)))
+            
+        obs = np.concatenate([get_finger_obs(index) for index in self.digits_indices])
+        return obs
 
     def _get_info(self):
         return {"sim_time": self.data.time - self.ep_start_time}
 
-    def _norm_to_target(self, obs):
-        """
-        Returns the norm of each fingertip to the target position
-        obs: an observation from the observation space [...fingertip_pos, ...target_pos, ...fingertip_vel]
-        """
-        obs = obs.reshape((-1, 3))
-        n_fingertips = len(self.fingertip_indices)
+    def position_norm(self, pos1, pos2):
+        """Returns the distance between two position vectors"""
+        return np.linalg.norm(pos1-pos2, ord=2, axis=-1)
 
-        fingertip_poses = obs[0:n_fingertips]
-        target_poses = obs[n_fingertips:2*n_fingertips]
-
-        return np.linalg.norm(fingertip_poses-target_poses, ord=2, axis=-1)
+    def orientation_norm(self, quat1, quat2):
+        """Returns the angular distance between two quaternion orientation"""
+        return 2*np.arccos(np.abs(np.dot(quat1, np.transpose(quat2)).diagonal()))
 
     def _get_reward(self, action, new_state):
         """
@@ -224,10 +340,20 @@ class DARMEnv(gym.Env):
         Agent is rewarded for coming close to the target beyond a threshold 
         """
 
-        reach_dist = self._norm_to_target(new_state)    # NOTE: Single finger
         near_th = self.min_th
+        angle_near_th = self.angle_min_th
         far_th = 2*self.max_target_th
 
+        fingertip_obs = np.zeros_like(self.target_obs)
+        for idx_str in self.digits:
+            fingertip_obs[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
+        reach_dist_all = self.position_norm(fingertip_obs[:, :3], self.target_obs[:, :3])
+        angle_dist_all = self.orientation_norm(fingertip_obs[:, 3:7], self.target_obs[:, 3:7])
+        # Compute reward only for active digits
+        reach_dist = reach_dist_all[self.digits_indices]
+        angle_dist = angle_dist_all[self.digits_indices]
+        contact = np.array([sum(self.get_finger_contacts(i)) for i in self.digits_indices])
+
         # Scale action down to [0, 1] from [0, max_tendon_tension]
         action = action / self.max_tendon_tension
         
@@ -235,14 +361,19 @@ class DARMEnv(gym.Env):
         # act_mag = np.linalg.norm(action.reshape(-1, 5)) # reshape action to (-1,5), ensure nu is ordered from mujoco
         # TODO: Consider scaling down this act_mag to be equiv. to a single finger with nu=5
         act_mag = np.linalg.norm(action)/np.sqrt(self.model.nu/1) # action magnitude is not measured per finger but as a whole
-        act_mag = np.array([act_mag]*len(self.fingertip_indices))
+        act_mag = np.array([act_mag]*len(self.digits))
         # by dividing by sqrt(nu/5), the norm is similar to when computing with nu==5. Check it out.
         # by dividing by sqrt(nu) act_mag will have a max value in the order of the max_value of action now => 1
         
+        # reach dist scaled from cm to m
+        reach_rwd = -1*0.01*reach_dist - 0.05*angle_dist
+        bonus_rwd = (1.*(np.logical_and((reach_dist<2*near_th), (angle_dist<2*angle_near_th))) + 
+                 1.*(np.logical_and((reach_dist<near_th), (angle_dist<angle_near_th))))
         rwd_dict = collections.OrderedDict((
             # Optional Keys
-            ('reach',   -1.*reach_dist),
-            ('bonus',   1.*(reach_dist<2*near_th) + 1.*(reach_dist<near_th)),
+            ('reach',   reach_rwd),
+            ('bonus',   bonus_rwd),
+            ('contact', -1*contact),
             ('act_reg', -1.*act_mag),
             ('penalty', -1.*(reach_dist>far_th)),
             # Must keys
@@ -253,19 +384,13 @@ class DARMEnv(gym.Env):
 
             # Weights:
             # reach = 1.0,
+            # contact = 1.0
             # bonus = 4.0,
             # penalty = 50,
             # act_reg = 0.1,
         rwd_dict['dense'] = np.sum([wt*rwd_dict[key] for key, wt in self.rwd_keys_wt.items()], axis=0)
         return rwd_dict
 
-    def _get_done(self, new_state):
-        return all(self._norm_to_target(new_state) < self.min_th)
-
-    def _check_collision(self):
-        """Returns True if there is collision, otherwise False"""
-        return len(self.data.contact.geom1) > 0
-
     def generate_start_state(self):
         while True:
             # ========================== Sample valid start_state from Joint Space ==========================
@@ -275,7 +400,7 @@ class DARMEnv(gym.Env):
             # joint_state = self.min_joint_vals + normal_sampling*(self.max_joint_vals - self.min_joint_vals)
             self.forward(joint_state)
 
-            if self._check_collision(): # returns True if there is collision
+            if self.digits_in_contact(): # returns True if there is collision between fingers
                 # ensure there is no collision at the start state
                 continue
             
@@ -285,21 +410,28 @@ class DARMEnv(gym.Env):
             target_joint_state = np.clip(a=joint_state + joint_state_delta, 
                                         a_min=self.min_joint_vals, 
                                         a_max=self.max_joint_vals)
-            self.target_obs = self.forward(target_joint_state)[:3*len(self.fingertip_indices)]
-            if self._check_collision(): # returns True if there is collision
+            self.forward(target_joint_state)
+            if self.digits_in_contact(): # returns True if there is collision
                 # ensure there is no collision at the target state
                 continue
             
+            for idx_str in self.digits:
+                self.target_obs[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
+            
             # Return to start state
             observation = self.forward(joint_state)
 
             # Verify distance of start state to target state is within limits
-            norm = self._norm_to_target(observation)
+            fingertip_obs = np.zeros_like(self.target_obs)
+            for idx_str in self.digits:
+                fingertip_obs[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
+            norm_all = self.position_norm(fingertip_obs[:, :3], self.target_obs[:, :3])
+            norm = norm_all[self.digits_indices]
             if not (all(norm >= self.min_target_th) and all(norm <= self.max_target_th)):
                 continue
             
             # If all checks are positive, break random search loop
-            return observation, joint_state, self.target_obs      
+            return observation, joint_state, self.target_obs.copy()      
 
     def sample_saved_start_states(self):
         # Sample a start state from saved start states
@@ -315,17 +447,20 @@ class DARMEnv(gym.Env):
         # Return Observation
         return observation
 
-    # def reset(self, seed=None, options=None):
-        # super().reset()
     def reset(self, **kwargs):
         # ========================== Get a random valid pose and target ==========================
         # observation, _, _ = self.generate_start_state()
         observation = self.sample_saved_start_states()
+        
+        for idx_str in self.digits:
+            self.prev_fingertip_pose[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
 
         # ========================== Render Frame ==========================
         if self.render_mode == "human":
-            # Update target visualization mocaps pos
-            self.data.mocap_pos = self.target_obs.reshape(len(self.fingertip_indices),3) + self.ref_pos
+            # Update target visualization mocaps pos and quat
+            target_pos = self.target_obs[self.digits_indices, :3]
+            self.data.mocap_pos = self.remove_distance_obs_transform(target_pos)
+            self.data.mocap_quat = self.target_obs[self.digits_indices, 3:]
             # Go Forward
             mj.mj_forward(self.model, self.data)
             self._render_frame()
@@ -334,7 +469,8 @@ class DARMEnv(gym.Env):
         return observation
 
     def step(self, action):
-        prev_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)
+        for idx_str in self.digits:
+            self.prev_fingertip_pose[self.index_str_mapping[idx_str]] = self.get_fingertip_pose(idx_str)
 
         # action from model is in the range [-1,1]
         # action + 1 === [0, 2]
@@ -350,138 +486,45 @@ class DARMEnv(gym.Env):
         time_after = self.data.time # time after performing action
 
 
-        # Get new observation (fingertips_pos)
-        new_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)
-        # include velocity in new obs
-        new_obs = self._get_obs(prev_obs=prev_obs,
-                                new_obs=new_obs, 
-                                action_time=time_after-time_prev)
+        # Get observation
+        obs = self._get_obs(action_time=time_after-time_prev)
 
         if self.render_mode == "human":
             self._render_frame()
 
         # Get Reward
-        rwd_dict = self._get_reward(action, new_obs)
+        rwd_dict = self._get_reward(action, obs)
         reward = rwd_dict["dense"].mean()
         done = any(rwd_dict["done"])  # all(rwd_dict["done"])
         
-        return new_obs, reward, done, {**self._get_info(), "action": action, "reward": {**rwd_dict}}
+        return obs, reward, done, {**self._get_info(), "action": action, "reward": {**rwd_dict}}
 
     def forward(self, joint_conf):
         self.data.qpos = joint_conf
         mj.mj_forward(self.model, self.data)
-        return self._get_obs(prev_obs=None, new_obs=None, action_time=None)
+        return self._get_obs(action_time=None)
 
-    def render(self, mode, **kwargs):
-        if self.render_mode == "human":
+    def render(self, mode="human", **kwargs):
+        if mode=="human" and self.render_mode == "human":
             return self._render_frame()
-        else:
-            T = 1/DARMEnv.metadata["render_fps"]    # period
-            if (self.data.time - self.last_frame_time) >= T:
-                self.renderer.update_scene(self.data, scene_option=self.scene_option)
-                self.last_frame = self.renderer.render()
-            return self.last_frame.copy()
+        # else:
+        #     T = 1/DARMEnv.metadata["render_fps"]    # period
+        #     if (self.data.time - self.last_frame_time) >= T:
+        #         self.renderer.update_scene(self.data, scene_option=self.scene_option)
+        #         self.last_frame = self.renderer.render()
+        #     return self.last_frame.copy()
 
     def _render_frame(self):
-        if self.render_mode == "human" and not self.window:
-            # Init GLFW, create window, make OpenGL context current, request v-sync
-            glfw.init()
-            self.window = glfw.create_window(self.window_size[0], self.window_size[1], "DARM", None, None)
-            glfw.make_context_current(self.window)
-            glfw.swap_interval(1)
-
-            # Visualization
-            self.cam = mj.MjvCamera()    # abstract camera
-            self.opt = mj.MjvOption()    # visualization options
-            mj.mjv_defaultCamera(self.cam)
-            mj.mjv_defaultOption(self.opt)
-            self.scene = mj.MjvScene(self.model, maxgeom=10000)
-            self.context = mj.MjrContext(self.model, mj.mjtFontScale.mjFONTSCALE_150.value)
-
-            self.cam.azimuth = 110
-            self.cam.elevation = -24
-            self.cam.distance = 0.36
-            self.cam.lookat = np.array([0.006, -0.004,  0.215])
-
-            # For callback functions TODO:
-            self.window_button_left = False
-            self.window_button_middle = False
-            self.window_button_right = False
-            self.window_lastx = 0
-            self.window_lasty = 0
-
-            def mouse_button(window, button, act, mods):
-                # update button state
-                self.window_button_left = (glfw.get_mouse_button(
-                    window, glfw.MOUSE_BUTTON_LEFT) == glfw.PRESS)
-                self.window_button_middle = (glfw.get_mouse_button(
-                    window, glfw.MOUSE_BUTTON_MIDDLE) == glfw.PRESS)
-                self.window_button_right = (glfw.get_mouse_button(
-                    window, glfw.MOUSE_BUTTON_RIGHT) == glfw.PRESS)
-
-                # update mouse position
-                glfw.get_cursor_pos(window) # TODO: Why is this needed again
-
-            def mouse_move(window, xpos, ypos):
-                # compute mouse displacement, save
-                dx = xpos - self.window_lastx
-                dy = ypos - self.window_lasty
-                self.window_lastx = xpos
-                self.window_lasty = ypos
-
-                # no buttons down: nothing to do
-                if (not self.window_button_left) and (not self.window_button_middle) and (not self.window_button_right):
-                    return
-
-                # get current window size
-                width, height = glfw.get_window_size(window)
-
-                # get shift key state
-                PRESS_LEFT_SHIFT = glfw.get_key(
-                    window, glfw.KEY_LEFT_SHIFT) == glfw.PRESS
-                PRESS_RIGHT_SHIFT = glfw.get_key(
-                    window, glfw.KEY_RIGHT_SHIFT) == glfw.PRESS
-                mod_shift = (PRESS_LEFT_SHIFT or PRESS_RIGHT_SHIFT)
-
-                # determine action based on mouse button
-                if self.window_button_right:
-                    if mod_shift:
-                        action = mj.mjtMouse.mjMOUSE_MOVE_H
-                    else:
-                        action = mj.mjtMouse.mjMOUSE_MOVE_V
-                elif self.window_button_left:
-                    if mod_shift:
-                        action = mj.mjtMouse.mjMOUSE_ROTATE_H
-                    else:
-                        action = mj.mjtMouse.mjMOUSE_ROTATE_V
-                else:
-                    action = mj.mjtMouse.mjMOUSE_ZOOM
-
-                mj.mjv_moveCamera(self.model, action, dx/width,
-                                dy/height, self.scene, self.cam)    # TODO: Look into this, height/width issue
-
-            def scroll(window, xoffset, yoffset):
-                action = mj.mjtMouse.mjMOUSE_ZOOM
-                mj.mjv_moveCamera(self.model, action, 0.0, -0.05 *
-                                yoffset, self.scene, self.cam)
-
-            glfw.set_cursor_pos_callback(self.window, mouse_move)
-            glfw.set_mouse_button_callback(self.window, mouse_button)
-            glfw.set_scroll_callback(self.window, scroll)
-        
-        # Get Framebuffer Viewport
-        vp_width, vp_height = glfw.get_framebuffer_size(self.window)
-        viewport = mj.MjrRect(0, 0, vp_width, vp_height)
+        self.darm_render.window_render()
 
-        # Update scene and render
-        mj.mjv_updateScene(self.model, self.data, self.opt, None, self.cam, mj.mjtCatBit.mjCAT_ALL.value, self.scene)
-        mj.mjr_render(viewport, self.scene, self.context)
-
-        # swap OpenGL buffers (blocking call due to v-sync)
-        glfw.swap_buffers(self.window)
+    def close(self):
+        if self.render_mode == "human":
+            self.darm_render.close_window()
 
-        # process pending GUI events, call GLFW callbacks
-        glfw.poll_events()
 
-    def close(self):
-        glfw.terminate()
\ No newline at end of file
+if __name__ == "__main__":
+    env = DARMEnv(render_mode="human")
+    env.reset()
+    while True:
+        env.render(mode="human")
+        
\ No newline at end of file
diff --git a/darm_gym_env/darm_render.py b/darm_gym_env/darm_render.py
new file mode 100644
index 0000000..f0b56ba
--- /dev/null
+++ b/darm_gym_env/darm_render.py
@@ -0,0 +1,140 @@
+import mujoco as mj
+from mujoco.glfw import glfw
+
+import os
+import numpy as np
+
+class DARMRender():
+    def __init__(self, model, data, window_size=(1200,900)):
+        self.model = model
+        self.data = data
+
+        self.window_size = window_size # (width, height)
+
+    def init_window_render(self):
+        # Init GLFW, create window, make OpenGL context current, request v-sync
+        glfw.init()
+        self.window = glfw.create_window(self.window_size[0], self.window_size[1], "DARM", None, None)
+        glfw.make_context_current(self.window)
+        glfw.swap_interval(1)   # TODO: What's this
+
+        # Visualization
+        self.cam = mj.MjvCamera()    # abstract camera
+        self.opt = mj.MjvOption()    # visualization options
+        mj.mjv_defaultCamera(self.cam)
+        mj.mjv_defaultOption(self.opt)
+        self.scene = mj.MjvScene(self.model, maxgeom=10000)
+        self.context = mj.MjrContext(self.model, mj.mjtFontScale.mjFONTSCALE_150.value)
+
+        self.cam.azimuth = 90
+        self.cam.elevation = -45
+        self.cam.distance = 2
+        self.cam.lookat = np.array([0.0, 0.0, 0])
+
+        # For callback functions
+        self.button_left = False
+        self.button_middle = False
+        self.button_right = False
+        self.lastx = 0
+        self.lasty = 0
+
+        def keyboard(window, key, scancode, act, mods):
+            if act == glfw.PRESS and key == glfw.KEY_BACKSPACE:
+                mj.mj_resetData(self.model, self.data)
+                mj.mj_forward(self.model, self.data)
+
+        def mouse_button(window, button, act, mods):
+            # update button state
+            self.button_left = (glfw.get_mouse_button(
+                window, glfw.MOUSE_BUTTON_LEFT) == glfw.PRESS)
+            self.button_middle = (glfw.get_mouse_button(
+                window, glfw.MOUSE_BUTTON_MIDDLE) == glfw.PRESS)
+            self.button_right = (glfw.get_mouse_button(
+                window, glfw.MOUSE_BUTTON_RIGHT) == glfw.PRESS)
+
+            # update mouse position
+            glfw.get_cursor_pos(window) # TODO: Why is this needed again
+
+        def mouse_move(window, xpos, ypos):
+            # compute mouse displacement, save
+            dx = xpos - self.lastx
+            dy = ypos - self.lasty
+            self.lastx = xpos
+            self.lasty = ypos
+
+            # no buttons down: nothing to do
+            if (not self.button_left) and (not self.button_middle) and (not self.button_right):
+                return
+
+            # get current window size
+            width, height = glfw.get_window_size(window)
+
+            # get shift key state
+            PRESS_LEFT_SHIFT = glfw.get_key(
+                window, glfw.KEY_LEFT_SHIFT) == glfw.PRESS
+            PRESS_RIGHT_SHIFT = glfw.get_key(
+                window, glfw.KEY_RIGHT_SHIFT) == glfw.PRESS
+            mod_shift = (PRESS_LEFT_SHIFT or PRESS_RIGHT_SHIFT)
+
+            # determine action based on mouse button
+            if self.button_right:
+                if mod_shift:
+                    action = mj.mjtMouse.mjMOUSE_MOVE_H
+                else:
+                    action = mj.mjtMouse.mjMOUSE_MOVE_V
+            elif self.button_left:
+                if mod_shift:
+                    action = mj.mjtMouse.mjMOUSE_ROTATE_H
+                else:
+                    action = mj.mjtMouse.mjMOUSE_ROTATE_V
+            else:
+                action = mj.mjtMouse.mjMOUSE_ZOOM
+
+            mj.mjv_moveCamera(self.model, action, dx/height,
+                            dy/height, self.scene, self.cam)
+
+        def scroll(window, xoffset, yoffset):
+            action = mj.mjtMouse.mjMOUSE_ZOOM
+            mj.mjv_moveCamera(self.model, action, 0.0, -0.05 *
+                            yoffset, self.scene, self.cam)
+
+        glfw.set_key_callback(self.window, keyboard)
+        glfw.set_cursor_pos_callback(self.window, mouse_move)
+        glfw.set_mouse_button_callback(self.window, mouse_button)
+        glfw.set_scroll_callback(self.window, scroll)
+
+    def window_render(self, model=None, data=None):
+        if not model: model = self.model
+        if not data: data = self.data
+
+        # Get Framebuffer Viewport
+        vp_width, vp_height = glfw.get_framebuffer_size(self.window)
+        viewport = mj.MjrRect(0, 0, vp_width, vp_height)
+
+        # Update scene and render
+        mj.mjv_updateScene(model, data, self.opt, None, self.cam, mj.mjtCatBit.mjCAT_ALL.value, self.scene)
+        mj.mjr_render(viewport, self.scene, self.context)
+
+        # swap OpenGL buffers (blocking call due to v-sync)
+        glfw.swap_buffers(self.window)
+
+        # process pending GUI events, call GLFW callbacks
+        glfw.poll_events()
+
+    def close_window(self):
+        glfw.terminate()
+
+if __name__ == "__main__":
+    DARM_XML_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/mujoco_env/darm.xml"
+
+    model = mj.MjModel.from_xml_path(DARM_XML_FILE)
+    data = mj.MjData(model)
+    
+    print("Creating Darm Object...")
+    darm = DARMRender(model, data)
+    darm.init_window_render()
+    while True:
+        data.qpos[1] += 0.1
+        mj.mj_forward(model, data)
+
+        darm.window_render()
\ No newline at end of file
diff --git a/darm_gym_env/generate_DARMHand_start_state.py b/darm_gym_env/generate_DARMHand_start_state.py
index e748d3d..cdac96e 100644
--- a/darm_gym_env/generate_DARMHand_start_state.py
+++ b/darm_gym_env/generate_DARMHand_start_state.py
@@ -1,5 +1,6 @@
 import gym
-from darm_gym_env import DARMEnv
+from darm_gym import DARMEnv
+# from darm_gym_env import DARMEnv
 import time
 import random
 import numpy as np
@@ -7,18 +8,21 @@ import os
 from tqdm import tqdm
 
 # ================================= TODO: CHECKLIST =================================
-# Change file path  /////Remove last 1000 obs from MFNW
+# Change file path
 # Change single_finger_env
 # Change Mujoco XML
 # ================================= TODO: CHECKLIST =================================
 
 # Choose single_finger or multi-fingers
-START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/DARMHand_SF_start_state.npy"
-# START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/DARMHand_MFNW_start_state.npy"
+START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/start_states/DARMHand_SF_start_state.npy"
+# START_STATE_FILE = f"{os.getenv('DARM_MUJOCO_PATH')}/darm_gym_env/start_states/DARMHand_MFNW_start_state.npy"
 
-env = gym.make("darm/DarmHand-v0", render_mode=None, hand_name="hand1",
-               single_finger_env=True,
-               ignore_load_start_states=True)
+env = DARMEnv(render_mode=None, hand_name="hand1",
+              digits=["ii"], ignore_load_start_states=True)
+
+# env = gym.make("darm/DarmHand-v0", render_mode=None, hand_name="hand1",
+#                single_finger_env=False,
+#                ignore_load_start_states=True)
 
 targets = []
 N_OBERVATIONS = int(1e5)
diff --git a/darm_gym_env/start_states/DARMHand_MFNW_start_state.npy b/darm_gym_env/start_states/DARMHand_MFNW_start_state.npy
new file mode 100644
index 0000000..591b105
Binary files /dev/null and b/darm_gym_env/start_states/DARMHand_MFNW_start_state.npy differ
diff --git a/darm_gym_env/start_states/DARMHand_SF_start_state.npy b/darm_gym_env/start_states/DARMHand_SF_start_state.npy
new file mode 100644
index 0000000..4cfd353
Binary files /dev/null and b/darm_gym_env/start_states/DARMHand_SF_start_state.npy differ
diff --git a/darm_gym_env/testing.ipynb b/darm_gym_env/testing.ipynb
index 008891a..3f147fa 100644
--- a/darm_gym_env/testing.ipynb
+++ b/darm_gym_env/testing.ipynb
@@ -1,5 +1,61 @@
 {
  "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 4,
+   "id": "84e18792",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Loaded XML file successfully\n"
+     ]
+    },
+    {
+     "ename": "KeyboardInterrupt",
+     "evalue": "",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
+      "\u001b[1;32m/home/daniel/DARM/darm_mujoco/darm_gym_env/testing.ipynb Cell 1\u001b[0m in \u001b[0;36m<cell line: 10>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     <a href='vscode-notebook-cell:/home/daniel/DARM/darm_mujoco/darm_gym_env/testing.ipynb#W0sZmlsZQ%3D%3D?line=10'>11</a>\u001b[0m start_time \u001b[39m=\u001b[39m time\u001b[39m.\u001b[39mtime()\n\u001b[1;32m     <a href='vscode-notebook-cell:/home/daniel/DARM/darm_mujoco/darm_gym_env/testing.ipynb#W0sZmlsZQ%3D%3D?line=11'>12</a>\u001b[0m \u001b[39mwhile\u001b[39;00m time\u001b[39m.\u001b[39mtime() \u001b[39m-\u001b[39m start_time \u001b[39m<\u001b[39m \u001b[39m4\u001b[39m:\n\u001b[0;32m---> <a href='vscode-notebook-cell:/home/daniel/DARM/darm_mujoco/darm_gym_env/testing.ipynb#W0sZmlsZQ%3D%3D?line=12'>13</a>\u001b[0m     env\u001b[39m.\u001b[39;49mrender()\n",
+      "File \u001b[0;32m~/miniconda3/lib/python3.8/site-packages/darm_gym_env-0.0.1-py3.8.egg/darm_gym_env/darm_gym.py:509\u001b[0m, in \u001b[0;36mDARMEnv.render\u001b[0;34m(self, mode, **kwargs)\u001b[0m\n\u001b[1;32m    507\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39mrender\u001b[39m(\u001b[39mself\u001b[39m, mode\u001b[39m=\u001b[39m\u001b[39m\"\u001b[39m\u001b[39mhuman\u001b[39m\u001b[39m\"\u001b[39m, \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mkwargs):\n\u001b[1;32m    508\u001b[0m     \u001b[39mif\u001b[39;00m mode\u001b[39m==\u001b[39m\u001b[39m\"\u001b[39m\u001b[39mhuman\u001b[39m\u001b[39m\"\u001b[39m \u001b[39mand\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mrender_mode \u001b[39m==\u001b[39m \u001b[39m\"\u001b[39m\u001b[39mhuman\u001b[39m\u001b[39m\"\u001b[39m:\n\u001b[0;32m--> 509\u001b[0m         \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_render_frame()\n",
+      "File \u001b[0;32m~/miniconda3/lib/python3.8/site-packages/darm_gym_env-0.0.1-py3.8.egg/darm_gym_env/darm_gym.py:518\u001b[0m, in \u001b[0;36mDARMEnv._render_frame\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    517\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39m_render_frame\u001b[39m(\u001b[39mself\u001b[39m):\n\u001b[0;32m--> 518\u001b[0m     \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49mdarm_render\u001b[39m.\u001b[39;49mwindow_render()\n",
+      "File \u001b[0;32m~/DARM/darm_mujoco/darm_gym_env/darm_render.py:111\u001b[0m, in \u001b[0;36mDARMRender.window_render\u001b[0;34m(self, model, data)\u001b[0m\n\u001b[1;32m    108\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39mnot\u001b[39;00m data: data \u001b[39m=\u001b[39m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39mdata\n\u001b[1;32m    110\u001b[0m \u001b[39m# Get Framebuffer Viewport\u001b[39;00m\n\u001b[0;32m--> 111\u001b[0m vp_width, vp_height \u001b[39m=\u001b[39m glfw\u001b[39m.\u001b[39;49mget_framebuffer_size(\u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49mwindow)\n\u001b[1;32m    112\u001b[0m viewport \u001b[39m=\u001b[39m mj\u001b[39m.\u001b[39mMjrRect(\u001b[39m0\u001b[39m, \u001b[39m0\u001b[39m, vp_width, vp_height)\n\u001b[1;32m    114\u001b[0m \u001b[39m# Update scene and render\u001b[39;00m\n",
+      "File \u001b[0;32m~/miniconda3/lib/python3.8/site-packages/glfw/__init__.py:1395\u001b[0m, in \u001b[0;36mget_framebuffer_size\u001b[0;34m(window)\u001b[0m\n\u001b[1;32m   1393\u001b[0m height_value \u001b[39m=\u001b[39m ctypes\u001b[39m.\u001b[39mc_int(\u001b[39m0\u001b[39m)\n\u001b[1;32m   1394\u001b[0m height \u001b[39m=\u001b[39m ctypes\u001b[39m.\u001b[39mpointer(height_value)\n\u001b[0;32m-> 1395\u001b[0m _glfw\u001b[39m.\u001b[39;49mglfwGetFramebufferSize(window, width, height)\n\u001b[1;32m   1396\u001b[0m \u001b[39mreturn\u001b[39;00m width_value\u001b[39m.\u001b[39mvalue, height_value\u001b[39m.\u001b[39mvalue\n",
+      "File \u001b[0;32m~/miniconda3/lib/python3.8/site-packages/glfw/__init__.py:682\u001b[0m, in \u001b[0;36m_prepare_errcheck.<locals>.errcheck\u001b[0;34m(result, *args)\u001b[0m\n\u001b[1;32m    674\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39m_prepare_errcheck\u001b[39m():\n\u001b[1;32m    675\u001b[0m     \u001b[39m\"\"\"\u001b[39;00m\n\u001b[1;32m    676\u001b[0m \u001b[39m    This function sets the errcheck attribute of all ctypes wrapped functions\u001b[39;00m\n\u001b[1;32m    677\u001b[0m \u001b[39m    to evaluate the _exc_info_from_callback global variable and re-raise any\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    680\u001b[0m \u001b[39m    using the _callback_exception_decorator.\u001b[39;00m\n\u001b[1;32m    681\u001b[0m \u001b[39m    \"\"\"\u001b[39;00m\n\u001b[0;32m--> 682\u001b[0m     \u001b[39mdef\u001b[39;00m \u001b[39merrcheck\u001b[39m(result, \u001b[39m*\u001b[39margs):\n\u001b[1;32m    683\u001b[0m         \u001b[39mglobal\u001b[39;00m _exc_info_from_callback\n\u001b[1;32m    684\u001b[0m         \u001b[39mif\u001b[39;00m _exc_info_from_callback \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n",
+      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
+     ]
+    }
+   ],
+   "source": [
+    "import gym\n",
+    "import time as time\n",
+    "import numpy as np\n",
+    "from darm_gym_env import DARMEnv\n",
+    "\n",
+    "env = DARMEnv(render_mode=\"human\", hand_name=\"hand1\", \n",
+    "              digits=[\"ii\"], start_state_file=\"DARMHand_SF_start_state.npy\")\n",
+    "\n",
+    "while True:\n",
+    "    env.reset()\n",
+    "    start_time = time.time()\n",
+    "    while time.time() - start_time < 4:\n",
+    "        env.render()\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "id": "60a637c3",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "env.close()"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": 1,
@@ -1030,10 +1086,6 @@
    "execution_count": 20,
    "id": "b8793054-affc-4910-baf0-d2dddd45de48",
    "metadata": {
-    "collapsed": true,
-    "jupyter": {
-     "outputs_hidden": true
-    },
     "tags": []
    },
    "outputs": [
diff --git a/darm_training/.ipynb_checkpoints/viz_model_darm_hand-checkpoint.ipynb b/darm_training/.ipynb_checkpoints/viz_model_darm_hand-checkpoint.ipynb
index 5e50fb0..6a97363 100644
--- a/darm_training/.ipynb_checkpoints/viz_model_darm_hand-checkpoint.ipynb
+++ b/darm_training/.ipynb_checkpoints/viz_model_darm_hand-checkpoint.ipynb
@@ -3,26 +3,27 @@
   {
    "cell_type": "code",
    "execution_count": 1,
-   "id": "a229aac2-06b6-4d29-b893-781ea1dc9bd5",
+   "id": "541fb6d4-b8a2-4461-b42a-d1c050203fb1",
    "metadata": {
     "tags": []
    },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Installing mediapy:\n",
-      "\u001b[33mWARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv\u001b[0m\u001b[33m\n",
-      "\u001b[0m"
-     ]
-    }
-   ],
+   "outputs": [],
    "source": [
     "# Graphics and plotting.\n",
     "print('Installing mediapy:')\n",
     "!command -v ffmpeg >/dev/null || (apt update && apt install -y ffmpeg)\n",
-    "!pip install -q mediapy\n",
+    "!pip install -q mediapy"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "id": "e5eed09e-b075-4a0c-a066-0143b39af216",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [],
+   "source": [
     "import mediapy as media\n",
     "import matplotlib.pyplot as plt"
    ]
@@ -37,6 +38,8 @@
    "outputs": [],
    "source": [
     "import os\n",
+    "import numpy as np\n",
+    "import mujoco as mujoco\n",
     "DARM_XML_FILE = f\"{os.getenv('DARM_MUJOCO_PATH')}/mujoco_env/darm.xml\"\n",
     "xml_path = DARM_XML_FILE\n",
     "\n",
@@ -45,10 +48,694 @@
     "renderer = mujoco.Renderer(model)"
    ]
   },
+  {
+   "cell_type": "markdown",
+   "id": "c281715b-5045-41b5-8c95-0b576a3195c1",
+   "metadata": {},
+   "source": [
+    "#### DARMEnv"
+   ]
+  },
   {
    "cell_type": "code",
-   "execution_count": 4,
-   "id": "89589b6d-aa85-49fe-a52d-c02b7bf81853",
+   "execution_count": 3,
+   "id": "73d7568e-dee2-451b-839a-e0844a773ae5",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Loaded XML file successfully\n"
+     ]
+    }
+   ],
+   "source": [
+    "import gym\n",
+    "from darm_gym_env import DARMEnv\n",
+    "\n",
+    "env = gym.make(\"darm/DarmHand-v0\", render_mode=None, hand_name=\"hand1\",\n",
+    "               single_finger_env=False)\n",
+    "obs = env.reset()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 7,
+   "id": "86d73499-0155-4ae7-b6e7-690c49dc3f03",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<table class=\"show_images\" style=\"border-spacing:0px;\"><tr><td style=\"padding:1px;\"><img width=\"320\" height=\"240\" style=\"image-rendering:auto; object-fit:cover;\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAADwCAIAAAD+Tyo8AAAA9UlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPBohR0AAXbPpmUAAAAASUVORK5CYII=\"/></td></tr></table>"
+      ],
+      "text/plain": [
+       "<IPython.core.display.HTML object>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    }
+   ],
+   "source": [
+    "media.show_image(env.render())"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "5c58466f-c665-4e13-869b-5c0278edc143",
+   "metadata": {},
+   "source": [
+    "#### End of DARMEnv"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 81,
+   "id": "125b27cf-27e0-436e-8ef5-6d4693c76ac2",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [],
+   "source": [
+    "fingertip_obs[:, :3], self.target_obs[:, :3]import gym\n",
+    "import mujoco as mj\n",
+    "class MjModel(gym.Env):\n",
+    "    metadata = {\"render_modes\": [\"human\"], \"render_fps\": 60}\n",
+    "\n",
+    "    def __init__(self, render_mode=None, action_time=0.08, hand_name=\"hand1\",\n",
+    "                min_th = 0.004,\n",
+    "                min_target_th = 2*0.004,\n",
+    "                max_target_th = 5*0.004, # 20 mm\n",
+    "                target_joint_state_delta = [],\n",
+    "                min_joint_vals = [],\n",
+    "                max_joint_vals = [],\n",
+    "                max_tendon_tension = [],\n",
+    "                single_finger_env = False,\n",
+    "                ignore_load_start_states = True,\n",
+    "                digits = [\"ii\"]\n",
+    "                ) -> None:\n",
+    "        super().__init__()\n",
+    "        assert render_mode is None or render_mode in self.metadata[\"render_modes\"]\n",
+    "        \n",
+    "\n",
+    "        # ========================== Env Parameters ==========================\n",
+    "        self.render_mode = render_mode\n",
+    "        self.hand_name = hand_name\n",
+    "        self.single_finger_env = single_finger_env\n",
+    "        self.action_time = action_time\n",
+    "        self.ep_start_time = 0  # episode start time\n",
+    "\n",
+    "\n",
+    "        # ========================== Load the Model ==========================\n",
+    "        self._load_model()\n",
+    "        self.model = model\n",
+    "        self.data = data\n",
+    "        if not (self.model and self.data):\n",
+    "            raise \"Error loading model\"\n",
+    "        self._get_fingertip_indices()\n",
+    "        \n",
+    "\n",
+    "        # ========================== Setup Rendering ==========================\n",
+    "        self.renderer = mj.Renderer(self.model)\n",
+    "        # enable joint visualization option:\n",
+    "        self.scene_option = mj.MjvOption()\n",
+    "        self.scene_option.flags[mj.mjtVisFlag.mjVIS_JOINT] = True\n",
+    "        self.last_frame = self.renderer.render()\n",
+    "        self.last_frame_time = 0\n",
+    "\n",
+    "\n",
+    "        # ========================== Load targets ==========================\n",
+    "        if not ignore_load_start_states:\n",
+    "            self._load_start_states()\n",
+    "\n",
+    "\n",
+    "        # ========================== Mujoco Model Simulation Parameters ==========================\n",
+    "        self.min_joint_vals = min_joint_vals or self._get_joint_limits(\"min\")   # degrees\n",
+    "        self.max_joint_vals = max_joint_vals or self._get_joint_limits(\"max\")   # degress\n",
+    "        # abs increament of joint state from starting state to target state\n",
+    "        self.target_joint_state_delta = target_joint_state_delta or self._compute_target_joint_state_delta()   # degrees\n",
+    "        self.max_tendon_tension = max_tendon_tension or self._get_actuator_ctrlrange(\"max\")\n",
+    "\n",
+    "        self.min_joint_vals = self.min_joint_vals*(np.pi/180)\n",
+    "        self.max_joint_vals = self.max_joint_vals*(np.pi/180)\n",
+    "        self.target_joint_state_delta = self.target_joint_state_delta*(np.pi/180)\n",
+    "\n",
+    "        self.min_th = min_th    # norm threshold in metres at which env is solved\n",
+    "        self.min_target_th = min_target_th  # min norm to target state\n",
+    "        self.max_target_th = max_target_th  # max norm to target state\n",
+    "\n",
+    "        # Initialize target observation\n",
+    "        self.target_obs = np.zeros((5,7))\n",
+    "        self.prev_fingertip_pose = np.zeros((5,7))\n",
+    "        \n",
+    "\n",
+    "\n",
+    "        # ========================== Reward Components Weights ==========================\n",
+    "        self.rwd_keys_wt = dict(\n",
+    "            reach = 1.0,\n",
+    "            bonus = 4.0,\n",
+    "            penalty = 50,\n",
+    "            act_reg = 0.01,\n",
+    "            # sparse = 1,\n",
+    "            # solved = 1, # review - weight should not be assigned to this?\n",
+    "            # done = 1 # review - weight should not be assigned to this?\n",
+    "        )\n",
+    "\n",
+    "\n",
+    "        # ========================== Get Ref Position ==========================\n",
+    "        # Reference Position is at the centre of the wrist\n",
+    "        # The ref pos will remain fixed since it was taken before simulation started\n",
+    "        mj.mj_forward(self.model, self.data)\n",
+    "        ref_body_idx = mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_BODY), f\"{self.hand_name}_rc_centre_block\")\n",
+    "        self.ref_pos = np.array(self.data.xpos[ref_body_idx])\n",
+    "\n",
+    "\n",
+    "        # ========================== Define Observation and Action Space ==========================\n",
+    "        self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, \n",
+    "                                                shape=(3*3*len(self.fingertip_indices),), \n",
+    "                                                dtype=np.float32)\n",
+    "        \n",
+    "\n",
+    "        # NOTE: Watch out for Box upper limit if Carpal Actuators are involved\n",
+    "        # FIXME: Fix action range in reward and step functions. Current ==> [0,2] after denorm\n",
+    "        # Define a mujoco action range array used for scaling\n",
+    "        self.action_space = gym.spaces.Box(low=np.array([-1.0]*self.model.nu), \n",
+    "                                            high=np.array([1.0]*self.model.nu), \n",
+    "                                            shape=(self.model.nu,), dtype=np.float32)\n",
+    "\n",
+    "\n",
+    "        # ========================== For Human Rendering ==========================\n",
+    "        self.window = None\n",
+    "        self.window_size = 1200, 900\n",
+    "\n",
+    "        # ========================== Others ==========================\n",
+    "        self.index_str_mapping = {\"i\":0, \"ii\":1, \"iii\":2, \"iv\":3, \"v\":4}\n",
+    "        self.index_int_mapping = {0:\"i\", 1:\"ii\", 2:\"iii\", 3:\"iv\", 4:\"v\"}\n",
+    "        self.digits = digits\n",
+    "\n",
+    "    def _load_model(self):\n",
+    "        xml_path = DARM_XML_FILE\n",
+    "        self.model = mj.MjModel.from_xml_path(xml_path)\n",
+    "\n",
+    "        if self.model: \n",
+    "            print(\"Loaded XML file successfully\") \n",
+    "        else:\n",
+    "            print(f\"Error Loading XML file: {xml_path}\")\n",
+    "            return\n",
+    "        \n",
+    "        self.data = mj.MjData(self.model)\n",
+    "        renderer = mj.Renderer(self.model)\n",
+    "\n",
+    "    def _load_start_states(self):\n",
+    "        if self.single_finger_env:\n",
+    "            filename = SF_START_STATE_FILE\n",
+    "        else:\n",
+    "            filename = MF_START_STATE_FILE\n",
+    "\n",
+    "        with open(filename, 'rb') as f:\n",
+    "            self.start_states = np.load(f, allow_pickle=True)\n",
+    "            self.start_states_len = len(self.start_states)\n",
+    "\n",
+    "    def _get_joint_limits(self, type = None):\n",
+    "        joint_limits = []\n",
+    "        for i in range(self.model.njnt):\n",
+    "            joint_limits.append(self.model.jnt_range[i]*(180/np.pi))\n",
+    "        \n",
+    "        joint_limits = np.asarray(joint_limits)\n",
+    "        \n",
+    "        if type == \"min\":\n",
+    "            return joint_limits[:, 0]\n",
+    "        if type == \"max\":\n",
+    "            return joint_limits[:, 1]\n",
+    "        \n",
+    "        return joint_limits[:, 0], joint_limits[:, 1]\n",
+    "\n",
+    "    def _compute_target_joint_state_delta(self):\n",
+    "        # return (self.max_joint_vals - self.min_joint_vals)//10  # for every range of 10 deg, have a delta of 1 deg\n",
+    "        joint_state_delta =  ((self.max_joint_vals - self.min_joint_vals)//40) * 2  # for every range of 40 deg, have a delta of 2 deg\n",
+    "        return np.clip(joint_state_delta, a_min=2, a_max=10)    # a minimum delta of 2 degrees, max of 10 degrees\n",
+    "\n",
+    "    def _get_actuator_ctrlrange(self, type = None):\n",
+    "        if type == \"min\":\n",
+    "            return np.array([self.model.actuator_ctrlrange[i][0] for i in range(self.model.nu)])\n",
+    "        if type == \"max\":\n",
+    "            return np.array([self.model.actuator_ctrlrange[i][1] for i in range(self.model.nu)])\n",
+    "    \n",
+    "        ctrl_range = np.array([self.model.actuator_ctrlrange[i] for i in range(self.model.nu)])\n",
+    "        return ctrl_range[:, 0], ctrl_range[:, 1] # (min, max)\n",
+    "\n",
+    "    def _init_controller(self):\n",
+    "        pass\n",
+    "\n",
+    "    def _controller_cb(self, model, data):\n",
+    "        pass\n",
+    "\n",
+    "    def _get_fingertip_indices(self):\n",
+    "        # NOTE: Remember to set the mocap index properly in reset()\n",
+    "        if self.single_finger_env:\n",
+    "            indices = [\"ii\"]\n",
+    "        else:\n",
+    "            indices = [\"i\", \"ii\", \"iii\", \"iv\", \"v\"]\n",
+    "\n",
+    "        self.fingertip_indices = [mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_SITE), f\"{self.hand_name}_fingertip_{i}\") for i in indices]\n",
+    "    \n",
+    "    def transform_distance_obs(self, obs):\n",
+    "        \"\"\"\n",
+    "        - Transforms the distance to be in the frame of the wrist (RC Joint)\n",
+    "        - Convert the distance reading to cm\n",
+    "        \"\"\"\n",
+    "        return (obs - self.data.body(f\"{self.hand_name}_rc_centre_block\").xpos)*100\n",
+    "\n",
+    "    def get_finger_frames_pos(self, idx_str):\n",
+    "        # get Proximal Phalanx frame\n",
+    "        def pp_frame():\n",
+    "            # BODY: ${hand_name}_proximal_phalanx_${index}\n",
+    "            frame_pos = self.data.body(f\"{self.hand_name}_proximal_phalanx_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "            \n",
+    "        # get Middle Phalanx frame\n",
+    "        def mp_frame():\n",
+    "            # BODY: ${hand_name}_middle_phalanx_${index} [ii to v]\n",
+    "            frame_pos = self.data.body(f\"{self.hand_name}_middle_phalanx_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "\n",
+    "        # get Distal Phalanx frame\n",
+    "        def dp_frame():\n",
+    "            # BODY: ${hand_name}_distal_phalanx_${index}\n",
+    "            frame_pos = self.data.body(f\"{self.hand_name}_distal_phalanx_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "\n",
+    "        # get fingertip frame\n",
+    "        def fingertip_frame():\n",
+    "            # SITE: ${hand_name}_fingertip_${index}\n",
+    "            frame_pos = self.data.site(f\"{self.hand_name}_fingertip_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "\n",
+    "        if idx_str == \"i\":\n",
+    "            return np.concatenate((pp_frame(), dp_frame(),\n",
+    "                                   fingertip_frame()))\n",
+    "        else:\n",
+    "            return np.concatenate((pp_frame(), mp_frame(),\n",
+    "                                   dp_frame(), fingertip_frame()))\n",
+    "\n",
+    "    def get_fingertip_pose(self, idx_str):\n",
+    "        \"\"\"Returns the position and orientation of the fingertip `idx_str`\"\"\"\n",
+    "\n",
+    "        fingertip_pos = self.data.site(f\"{self.hand_name}_fingertip_{idx_str}\").xpos\n",
+    "        fingertip_pos = self.transform_distance_obs(fingertip_pos)\n",
+    "\n",
+    "        fingertip_orient = self.data.body(f\"{self.hand_name}_distal_phalanx_{idx_str}\").xquat\n",
+    "\n",
+    "        return np.concatenate((fingertip_pos, fingertip_orient))        \n",
+    "\n",
+    "    def get_finger_contacts(self, index):\n",
+    "        contact_geoms1 = self.data.contact.geom1\n",
+    "        contact_geoms2 = self.data.contact.geom2\n",
+    "\n",
+    "        colliding_digits = []\n",
+    "        colliding_with_palm = False\n",
+    "\n",
+    "        def get_digit_str(name):\n",
+    "            if name.endswith(\"_i\"): return \"i\"\n",
+    "            if name.endswith(\"_ii\"): return \"ii\"\n",
+    "            if name.endswith(\"_iii\"): return \"iii\"\n",
+    "            if name.endswith(\"_iv\"): return \"iv\"\n",
+    "            if name.endswith(\"_v\"): return \"v\"\n",
+    "            \n",
+    "            return None\n",
+    "\n",
+    "        def filter_contacts(contacts1, contacts2):\n",
+    "            for idx in range(len(contacts1)):\n",
+    "                geom_idx = contacts1[idx]\n",
+    "                # Ignore Wraps\n",
+    "                if \"_wrap\" in self.model.geom(geom_idx).name:\n",
+    "                    continue\n",
+    "                \n",
+    "                # Get the Body name\n",
+    "                bodyid = self.model.geom(geom_idx).bodyid[0]\n",
+    "                bodyname = self.model.body(bodyid).name\n",
+    "\n",
+    "                # If body is in current phalanges group\n",
+    "                if bodyname.endswith(f\"_phalanx_{self.index_int_mapping[index]}\"):\n",
+    "                    coll_geom_idx = contacts2[idx]\n",
+    "                    # Ignore Wraps\n",
+    "                    if \"_wrap\" in self.model.geom(coll_geom_idx).name:\n",
+    "                        continue\n",
+    "\n",
+    "                    # Get the body collided with\n",
+    "                    coll_bodyid = self.model.geom(coll_geom_idx).bodyid[0]\n",
+    "                    coll_bodyname = self.model.body(coll_bodyid).name\n",
+    "\n",
+    "                    if coll_bodyname == \"hand1_carpals_metacarpals\":\n",
+    "                        nonlocal colliding_with_palm\n",
+    "                        colliding_with_palm = True\n",
+    "\n",
+    "                    digit = get_digit_str(coll_bodyname)\n",
+    "                    if digit and (digit != self.index_int_mapping[index]):\n",
+    "                        colliding_digits.append(digit)\n",
+    "\n",
+    "        filter_contacts(contact_geoms1, contact_geoms2)\n",
+    "        filter_contacts(contact_geoms2, contact_geoms1)\n",
+    "\n",
+    "        collision_obs = np.zeros(6)\n",
+    "        if colliding_with_palm: collision_obs[0] = 1\n",
+    "        for idx_str in colliding_digits:\n",
+    "            collision_obs[self.index_str_mapping[idx_str]+1] = 1\n",
+    "\n",
+    "        return collision_obs\n",
+    "\n",
+    "    def digits_in_contact(self):\n",
+    "        indices = [self.index_str_mapping[i] for i in [\"i\", \"ii\", \"iii\", \"iv\", \"v\"]]\n",
+    "        contacts = np.concatenate([self.get_finger_contacts(index) for index in indices])\n",
+    "        return sum(contacts) > 0\n",
+    "\n",
+    "    def get_obs(self, action_time=None):\n",
+    "        def get_target_pose(index):\n",
+    "            return self.target_obs[index]\n",
+    "\n",
+    "        def get_kinematic_chain_obs(index):\n",
+    "            return self.get_finger_frames_pos(self.index_int_mapping[index])\n",
+    "\n",
+    "        def get_vel_obs(index):\n",
+    "            if not action_time:\n",
+    "                # if no action time, velocity is zero. i.e. after reset\n",
+    "                return np.zeros(3)\n",
+    "            \n",
+    "            prev_fingertip_pos = self.prev_fingertip_pose[index][:3]\n",
+    "            new_fingertip_pos = self.get_fingertip_pose(self.index_int_mapping[index])[:3]\n",
+    "            vel_obs = (new_fingertip_pos - prev_fingertip_pos)/action_time\n",
+    "            return vel_obs\n",
+    "\n",
+    "        def get_contact_obs(index):\n",
+    "            return self.get_finger_contacts(index)\n",
+    "\n",
+    "        def get_finger_obs(index):\n",
+    "            return np.concatenate((get_target_pose(index),\n",
+    "                            get_kinematic_chain_obs(index),\n",
+    "                            get_vel_obs(index),\n",
+    "                            get_contact_obs(index)))\n",
+    "            \n",
+    "        indices = [self.index_str_mapping[i] for i in self.digits]\n",
+    "        obs = np.concatenate([get_finger_obs(index) for index in indices])\n",
+    "        return obs\n",
+    "\n",
+    "    def _get_info(self):\n",
+    "        return {\"sim_time\": self.data.time - self.ep_start_time}\n",
+    "\n",
+    "    def _norm_to_target(self, obs):\n",
+    "        \"\"\"\n",
+    "        Returns the norm of each fingertip to the target position\n",
+    "        obs: an observation from the observation space [...fingertip_pos, ...target_pos, ...fingertip_vel]\n",
+    "        \"\"\"\n",
+    "        obs = obs.reshape((-1, 3))\n",
+    "        n_fingertips = len(self.fingertip_indices)\n",
+    "\n",
+    "        fingertip_poses = obs[0:n_fingertips]\n",
+    "        target_poses = obs[n_fingertips:2*n_fingertips]\n",
+    "\n",
+    "        return np.linalg.norm(fingertip_poses-target_poses, ord=2, axis=-1)\n",
+    "\n",
+    "    def _get_reward(self, action, new_state):\n",
+    "        \"\"\"\n",
+    "        Reward function to compute reward given action, and new state.\n",
+    "        R = R(a, S')\n",
+    "\n",
+    "        Agent is punished for being far from target\n",
+    "        Agent is punished for going farther than a threshold from the target\n",
+    "        Agent is punished for high action magnitude\n",
+    "        Agent is rewarded for being close to the target\n",
+    "        Agent is rewarded for coming close to the target beyond a threshold \n",
+    "        \"\"\"\n",
+    "\n",
+    "        reach_dist = self._norm_to_target(new_state)    # NOTE: Single finger\n",
+    "        near_th = self.min_th\n",
+    "        far_th = 2*self.max_target_th\n",
+    "\n",
+    "        # Scale action down to [0, 1] from [0, max_tendon_tension]\n",
+    "        action = action / self.max_tendon_tension\n",
+    "        \n",
+    "        # NOTE: Some of the fingers in five fingered hand have more than five actuators\n",
+    "        # act_mag = np.linalg.norm(action.reshape(-1, 5)) # reshape action to (-1,5), ensure nu is ordered from mujoco\n",
+    "        # TODO: Consider scaling down this act_mag to be equiv. to a single finger with nu=5\n",
+    "        act_mag = np.linalg.norm(action)/np.sqrt(self.model.nu/1) # action magnitude is not measured per finger but as a whole\n",
+    "        act_mag = np.array([act_mag]*len(self.fingertip_indices))\n",
+    "        # by dividing by sqrt(nu/5), the norm is similar to when computing with nu==5. Check it out.\n",
+    "        # by dividing by sqrt(nu) act_mag will have a max value in the order of the max_value of action now => 1\n",
+    "        \n",
+    "        rwd_dict = collections.OrderedDict((\n",
+    "            # Optional Keys\n",
+    "            ('reach',   -1.*reach_dist),\n",
+    "            ('bonus',   1.*(reach_dist<2*near_th) + 1.*(reach_dist<near_th)),\n",
+    "            ('act_reg', -1.*act_mag),\n",
+    "            ('penalty', -1.*(reach_dist>far_th)),\n",
+    "            # Must keys\n",
+    "            ('sparse',  -1.*reach_dist),\n",
+    "            ('solved',  reach_dist<near_th),\n",
+    "            ('done',    reach_dist > far_th),\n",
+    "        ))\n",
+    "\n",
+    "            # Weights:\n",
+    "            # reach = 1.0,\n",
+    "            # bonus = 4.0,\n",
+    "            # penalty = 50,\n",
+    "            # act_reg = 0.1,\n",
+    "        rwd_dict['dense'] = np.sum([wt*rwd_dict[key] for key, wt in self.rwd_keys_wt.items()], axis=0)\n",
+    "        return rwd_dict\n",
+    "\n",
+    "    def _get_done(self, new_state):\n",
+    "        return all(self._norm_to_target(new_state) < self.min_th)\n",
+    "\n",
+    "    def _check_collision(self):\n",
+    "        \"\"\"Returns True if there is collision, otherwise False\"\"\"\n",
+    "        return len(self.data.contact.geom1) > 0\n",
+    "\n",
+    "    def generate_start_state(self):\n",
+    "        while True:\n",
+    "            # ========================== Sample valid start_state from Joint Space ==========================\n",
+    "            joint_state = np.random.uniform(low=self.min_joint_vals, high=self.max_joint_vals)\n",
+    "            # normal_sampling = np.random.normal(loc=0.5, scale=0.5/3, size=self.min_joint_vals.shape)\n",
+    "            # normal_sampling = np.clip(normal_sampling, 0, 1)\n",
+    "            # joint_state = self.min_joint_vals + normal_sampling*(self.max_joint_vals - self.min_joint_vals)\n",
+    "            self.forward(joint_state)\n",
+    "\n",
+    "            if self._check_collision(): # returns True if there is collision\n",
+    "                # ensure there is no collision at the start state\n",
+    "                continue\n",
+    "            \n",
+    "        \n",
+    "            # ========================== Create a valid target ==========================\n",
+    "            joint_state_delta = self.target_joint_state_delta*np.random.choice(a=[-1,1], size=(self.model.njnt,), replace=True)\n",
+    "            target_joint_state = np.clip(a=joint_state + joint_state_delta, \n",
+    "                                        a_min=self.min_joint_vals, \n",
+    "                                        a_max=self.max_joint_vals)\n",
+    "            self.target_obs = self.forward(target_joint_state)[:3*len(self.fingertip_indices)]\n",
+    "            if self._check_collision(): # returns True if there is collision\n",
+    "                # ensure there is no collision at the target state\n",
+    "                continue\n",
+    "            \n",
+    "            # Return to start state\n",
+    "            observation = self.forward(joint_state)\n",
+    "\n",
+    "            # Verify distance of start state to target state is within limits\n",
+    "            norm = self._norm_to_target(observation)\n",
+    "            if not (all(norm >= self.min_target_th) and all(norm <= self.max_target_th)):\n",
+    "                continue\n",
+    "            \n",
+    "            # If all checks are positive, break random search loop\n",
+    "            return observation, joint_state, self.target_obs      \n",
+    "\n",
+    "    def sample_saved_start_states(self):\n",
+    "        # Sample a start state from saved start states\n",
+    "        # start_state = [joint_state, target_obs]\n",
+    "        start_state = self.start_states[np.random.randint(self.start_states_len)]\n",
+    "\n",
+    "        # Set Target Obs\n",
+    "        self.target_obs = start_state[1]\n",
+    "\n",
+    "        # Go forward to start state\n",
+    "        observation = self.forward(start_state[0])\n",
+    "\n",
+    "        # Return Observation\n",
+    "        return observation\n",
+    "\n",
+    "    def reset(self, **kwargs):\n",
+    "        # ========================== Get a random valid pose and target ==========================\n",
+    "        # observation, _, _ = self.generate_start_state()\n",
+    "        observation = self.sample_saved_start_states()\n",
+    "\n",
+    "        # ========================== Render Frame ==========================\n",
+    "        if self.render_mode == \"human\":\n",
+    "            # Update target visualization mocaps pos\n",
+    "            self.data.mocap_pos = self.target_obs.reshape(len(self.fingertip_indices),3) + self.ref_pos\n",
+    "            # Go Forward\n",
+    "            mj.mj_forward(self.model, self.data)\n",
+    "            self._render_frame()\n",
+    "\n",
+    "        self.ep_start_time = self.data.time\n",
+    "        return observation\n",
+    "\n",
+    "    def step(self, action):\n",
+    "        prev_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)\n",
+    "\n",
+    "        # action from model is in the range [-1,1]\n",
+    "        # action + 1 === [0, 2]\n",
+    "        # action * x === [0, 2x]\n",
+    "        action = (action + 1)*(self.max_tendon_tension/2)\n",
+    "        action = np.clip(action, 0, self.max_tendon_tension)\n",
+    "        self.data.ctrl[0 : self.model.nu] = action\n",
+    "        time_prev = self.data.time   # simulation time in seconds\n",
+    "\n",
+    "        # Perform action  \n",
+    "        while (self.data.time - time_prev < self.action_time):\n",
+    "            mj.mj_step(self.model, self.data)\n",
+    "        time_after = self.data.time # time after performing action\n",
+    "\n",
+    "\n",
+    "        # Get new observation (fingertips_pos)\n",
+    "        new_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)\n",
+    "        # include velocity in new obs\n",
+    "        new_obs = self._get_obs(prev_obs=prev_obs,\n",
+    "                                new_obs=new_obs, \n",
+    "                                action_time=time_after-time_prev)\n",
+    "\n",
+    "        if self.render_mode == \"human\":\n",
+    "            self._render_frame()\n",
+    "\n",
+    "        # Get Reward\n",
+    "        rwd_dict = self._get_reward(action, new_obs)\n",
+    "        reward = rwd_dict[\"dense\"].mean()\n",
+    "        done = any(rwd_dict[\"done\"])  # all(rwd_dict[\"done\"])\n",
+    "        \n",
+    "        return new_obs, reward, done, {**self._get_info(), \"action\": action, \"reward\": {**rwd_dict}}\n",
+    "\n",
+    "    def forward(self, joint_conf):\n",
+    "        self.data.qpos = joint_conf\n",
+    "        mj.mj_forward(self.model, self.data)\n",
+    "        return self._get_obs(prev_obs=None, new_obs=None, action_time=None)\n",
+    "\n",
+    "    def render(self, mode, **kwargs):\n",
+    "        if self.render_mode == \"human\":\n",
+    "            return self._render_frame()\n",
+    "        else:\n",
+    "            T = 1/DARMEnv.metadata[\"render_fps\"]    # period\n",
+    "            if (self.data.time - self.last_frame_time) >= T:\n",
+    "                self.renderer.update_scene(self.data, scene_option=self.scene_option)\n",
+    "                self.last_frame = self.renderer.render()\n",
+    "            return self.last_frame.copy()\n",
+    "\n",
+    "    def _render_frame(self):\n",
+    "        if self.render_mode == \"human\" and not self.window:\n",
+    "            # Init GLFW, create window, make OpenGL context current, request v-sync\n",
+    "            glfw.init()\n",
+    "            self.window = glfw.create_window(self.window_size[0], self.window_size[1], \"DARM\", None, None)\n",
+    "            glfw.make_context_current(self.window)\n",
+    "            glfw.swap_interval(1)\n",
+    "\n",
+    "            # Visualization\n",
+    "            self.cam = mj.MjvCamera()    # abstract camera\n",
+    "            self.opt = mj.MjvOption()    # visualization options\n",
+    "            mj.mjv_defaultCamera(self.cam)\n",
+    "            mj.mjv_defaultOption(self.opt)\n",
+    "            self.scene = mj.MjvScene(self.model, maxgeom=10000)\n",
+    "            self.context = mj.MjrContext(self.model, mj.mjtFontScale.mjFONTSCALE_150.value)\n",
+    "\n",
+    "            self.cam.azimuth = 110\n",
+    "            self.cam.elevation = -24\n",
+    "            self.cam.distance = 0.36\n",
+    "            self.cam.lookat = np.array([0.006, -0.004,  0.215])\n",
+    "\n",
+    "            # For callback functions TODO:\n",
+    "            self.window_button_left = False\n",
+    "            self.window_button_middle = False\n",
+    "            self.window_button_right = False\n",
+    "            self.window_lastx = 0\n",
+    "            self.window_lasty = 0\n",
+    "\n",
+    "            def mouse_button(window, button, act, mods):\n",
+    "                # update button state\n",
+    "                self.window_button_left = (glfw.get_mouse_button(\n",
+    "                    window, glfw.MOUSE_BUTTON_LEFT) == glfw.PRESS)\n",
+    "                self.window_button_middle = (glfw.get_mouse_button(\n",
+    "                    window, glfw.MOUSE_BUTTON_MIDDLE) == glfw.PRESS)\n",
+    "                self.window_button_right = (glfw.get_mouse_button(\n",
+    "                    window, glfw.MOUSE_BUTTON_RIGHT) == glfw.PRESS)\n",
+    "\n",
+    "                # update mouse position\n",
+    "                glfw.get_cursor_pos(window) # TODO: Why is this needed again\n",
+    "\n",
+    "            def mouse_move(window, xpos, ypos):\n",
+    "                # compute mouse displacement, save\n",
+    "                dx = xpos - self.window_lastx\n",
+    "                dy = ypos - self.window_lasty\n",
+    "                self.window_lastx = xpos\n",
+    "                self.window_lasty = ypos\n",
+    "\n",
+    "                # no buttons down: nothing to do\n",
+    "                if (not self.window_button_left) and (not self.window_button_middle) and (not self.window_button_right):\n",
+    "                    return\n",
+    "\n",
+    "                # get current window size\n",
+    "                width, height = glfw.get_window_size(window)\n",
+    "\n",
+    "                # get shift key state\n",
+    "                PRESS_LEFT_SHIFT = glfw.get_key(\n",
+    "                    window, glfw.KEY_LEFT_SHIFT) == glfw.PRESS\n",
+    "                PRESS_RIGHT_SHIFT = glfw.get_key(\n",
+    "                    window, glfw.KEY_RIGHT_SHIFT) == glfw.PRESS\n",
+    "                mod_shift = (PRESS_LEFT_SHIFT or PRESS_RIGHT_SHIFT)\n",
+    "\n",
+    "                # determine action based on mouse button\n",
+    "                if self.window_button_right:\n",
+    "                    if mod_shift:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_MOVE_H\n",
+    "                    else:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_MOVE_V\n",
+    "                elif self.window_button_left:\n",
+    "                    if mod_shift:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_ROTATE_H\n",
+    "                    else:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_ROTATE_V\n",
+    "                else:\n",
+    "                    action = mj.mjtMouse.mjMOUSE_ZOOM\n",
+    "\n",
+    "                mj.mjv_moveCamera(self.model, action, dx/width,\n",
+    "                                dy/height, self.scene, self.cam)    # TODO: Look into this, height/width issue\n",
+    "\n",
+    "            def scroll(window, xoffset, yoffset):\n",
+    "                action = mj.mjtMouse.mjMOUSE_ZOOM\n",
+    "                mj.mjv_moveCamera(self.model, action, 0.0, -0.05 *\n",
+    "                                yoffset, self.scene, self.cam)\n",
+    "\n",
+    "            glfw.set_cursor_pos_callback(self.window, mouse_move)\n",
+    "            glfw.set_mouse_button_callback(self.window, mouse_button)\n",
+    "            glfw.set_scroll_callback(self.window, scroll)\n",
+    "        \n",
+    "        # Get Framebuffer Viewport\n",
+    "        vp_width, vp_height = glfw.get_framebuffer_size(self.window)\n",
+    "        viewport = mj.MjrRect(0, 0, vp_width, vp_height)\n",
+    "\n",
+    "        # Update scene and render\n",
+    "        mj.mjv_updateScene(self.model, self.data, self.opt, None, self.cam, mj.mjtCatBit.mjCAT_ALL.value, self.scene)\n",
+    "        mj.mjr_render(viewport, self.scene, self.context)\n",
+    "\n",
+    "        # swap OpenGL buffers (blocking call due to v-sync)\n",
+    "        glfw.swap_buffers(self.window)\n",
+    "\n",
+    "        # process pending GUI events, call GLFW callbacks\n",
+    "        glfw.poll_events()\n",
+    "\n",
+    "    def close(self):\n",
+    "        glfw.terminate()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 76,
+   "id": "c1febf74-416a-42e0-b1c2-b5afd3a53d65",
    "metadata": {
     "tags": []
    },
@@ -56,7 +743,7 @@
     {
      "data": {
       "text/html": [
-       "<table class=\"show_images\" style=\"border-spacing:0px;\"><tr><td style=\"padding:1px;\"><img width=\"320\" height=\"240\" style=\"image-rendering:auto; object-fit:cover;\" src=\"data:image/png;base64,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\"/></td></tr></table>"
+       "<table class=\"show_images\" style=\"border-spacing:0px;\"><tr><td style=\"padding:1px;\"><img width=\"320\" height=\"240\" style=\"image-rendering:auto; object-fit:cover;\" src=\"data:image/png;base64,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\"/></td></tr></table>"
       ],
       "text/plain": [
        "<IPython.core.display.HTML object>"
@@ -75,7 +762,399 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 2,
+   "execution_count": 84,
+   "id": "8b3a7994-f031-4945-a3a6-5b6a46e07c99",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Loaded XML file successfully\n"
+     ]
+    },
+    {
+     "data": {
+      "text/plain": [
+       "array([1., 0., 1., 0., 1., 0.])"
+      ]
+     },
+     "execution_count": 84,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "model_cl = MjModel()\n",
+    "model_cl.get_finger_contacts(0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 85,
+   "id": "ea70c616-4b55-4914-9fa8-4aa73a681096",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "True"
+      ]
+     },
+     "execution_count": 85,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "model_cl.digits_in_contact()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 74,
+   "id": "7a92564c-6abf-4898-b179-cb79d4055fc2",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(28,\n",
+       " array([  0.        ,   0.        ,   0.        ,   0.        ,\n",
+       "          0.        ,   0.        ,   0.        ,   2.93      ,\n",
+       "          0.87      ,   9.08      ,   3.35532002,   0.87      ,\n",
+       "         13.94143013,   3.58889742,   0.87      ,  16.61123192,\n",
+       "          3.77279603,   0.87      ,  18.71320273,  47.1599504 ,\n",
+       "         10.875     , 233.91503413,   0.        ,   0.        ,\n",
+       "          0.        ,   0.        ,   0.        ,   0.        ]))"
+      ]
+     },
+     "execution_count": 74,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "len(model_cl.get_obs(0.08)), model_cl.get_obs(0.08)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 68,
+   "id": "c0d8a340-7c0e-47bf-a2b5-9e934fbcdab2",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(array([12, 45], dtype=int32), array([47, 26], dtype=int32))"
+      ]
+     },
+     "execution_count": 68,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.contact.geom1, data.contact.geom2"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 49,
+   "id": "361b5cba-33cc-4f3e-9a44-9a872552647b",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<_MjDataGeomViews\n",
+       "  id: 47\n",
+       "  name: ''\n",
+       "  xmat: array([-0.08988067, -0.97442545, -0.20595267,  0.99594543, -0.08715574,\n",
+       "       -0.02228407,  0.00376421, -0.20712052,  0.97830819])\n",
+       "  xpos: array([-0.03139738,  0.00431935,  0.25504528])\n",
+       ">"
+      ]
+     },
+     "execution_count": 49,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.body(47)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 77,
+   "id": "e5179678-ab1b-488e-acb1-c080c08873c8",
+   "metadata": {
+    "collapsed": true,
+    "jupyter": {
+     "outputs_hidden": true
+    },
+    "tags": []
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "world\n",
+      "hand1_fingertip_i_target\n",
+      "hand1_fingertip_ii_target\n",
+      "hand1_fingertip_iii_target\n",
+      "hand1_fingertip_iv_target\n",
+      "hand1_fingertip_v_target\n",
+      "hand1_forearm\n",
+      "hand1_rc_centre_block\n",
+      "hand1_carpals_metacarpals\n",
+      "hand1_mcp_centre_block_ii\n",
+      "hand1_proximal_phalanx_ii\n",
+      "hand1_middle_phalanx_ii\n",
+      "hand1_distal_phalanx_ii\n",
+      "hand1_mcp_centre_block_iii\n",
+      "hand1_proximal_phalanx_iii\n",
+      "hand1_middle_phalanx_iii\n",
+      "hand1_distal_phalanx_iii\n",
+      "hand1_mcp_centre_block_iv\n",
+      "hand1_proximal_phalanx_iv\n",
+      "hand1_middle_phalanx_iv\n",
+      "hand1_distal_phalanx_iv\n",
+      "hand1_proximal_cm_i_centre_block\n",
+      "hand1_distal_cm_i_centre_block\n",
+      "hand1_metacarpal_i\n",
+      "hand1_proximal_phalanx_i\n",
+      "hand1_distal_phalanx_i\n",
+      "hand1_proximal_cm_v_centre_block\n",
+      "hand1_distal_cm_v_centre_block\n",
+      "hand1_metacarpal_v\n",
+      "hand1_mcp_centre_block_v\n",
+      "hand1_proximal_phalanx_v\n",
+      "hand1_middle_phalanx_v\n"
+     ]
+    }
+   ],
+   "source": [
+    "for i in range(32):\n",
+    "    print(model.body(i).name or \"NO NAME\")"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 15,
+   "id": "bf6a30a7-8157-45c5-ad19-c5cd2956f682",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "0 hand1_carpals_metacarpals NO_NAME\n",
+      "1 hand1_carpals_metacarpals hand1_mcp_iv_wrap\n",
+      "2 hand1_distal_phalanx_ii NO_NAME\n",
+      "3 hand1_metacarpal_i hand1_mcp_i_wrap\n",
+      "4 hand1_distal_phalanx_ii NO_NAME\n",
+      "5 hand1_proximal_phalanx_iv NO_NAME\n",
+      "6 hand1_proximal_phalanx_i hand1_ip_i_wrap\n",
+      "7 hand1_proximal_phalanx_iv NO_NAME\n",
+      "8 hand1_metacarpal_v hand1_mcp_v_wrap\n",
+      "9 hand1_middle_phalanx_iv NO_NAME\n",
+      "10 hand1_middle_phalanx_iv hand1_pip_iv_wrap\n"
+     ]
+    }
+   ],
+   "source": [
+    "sn = 0\n",
+    "for idx in data.contact.geom1: #range(53):\n",
+    "    print(sn, model.body(model.geom(idx).bodyid[0]).name, model.geom(idx).name or \"NO_NAME\")\n",
+    "    sn += 1"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 16,
+   "id": "baebb727-2782-4f28-9675-934dd3c0a5e2",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "0 hand1_proximal_phalanx_i NO_NAME\n",
+      "1 hand1_proximal_phalanx_v NO_NAME\n",
+      "2 hand1_metacarpal_i NO_NAME\n",
+      "3 hand1_distal_phalanx_ii NO_NAME\n",
+      "4 hand1_proximal_phalanx_i NO_NAME\n",
+      "5 hand1_proximal_phalanx_i NO_NAME\n",
+      "6 hand1_proximal_phalanx_iv NO_NAME\n",
+      "7 hand1_distal_phalanx_i NO_NAME\n",
+      "8 hand1_proximal_phalanx_iv NO_NAME\n",
+      "9 hand1_distal_phalanx_i NO_NAME\n",
+      "10 hand1_distal_phalanx_i NO_NAME\n"
+     ]
+    }
+   ],
+   "source": [
+    "sn = 0\n",
+    "for idx in data.contact.geom2: #range(53):\n",
+    "    print(sn, model.body(model.geom(idx).bodyid[0]).name, model.geom(idx).name or \"NO_NAME\")\n",
+    "    sn += 1"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 75,
+   "id": "06912a81-2b6d-447d-b426-41ae0ff33184",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "data.joint(11).qpos = 0.605 # np.radians(60)\n",
+    "data.joint(16).qpos = -0.349 # np.radians(60)\n",
+    "\n",
+    "data.joint(2).qpos = 0.349\n",
+    "data.joint(3).qpos = 1.57\n",
+    "data.joint(4).qpos = 1.57\n",
+    "data.joint(5).qpos = 1.57"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 24,
+   "id": "35ec58b6-43fb-4d8d-99c6-06b376b8173a",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(array([ 0.92094275,  0.37735207,  0.0068244 , -0.09707367]),\n",
+       " array([ 0.99524654, -0.00380168,  0.0434534 , -0.08707279]))"
+      ]
+     },
+     "execution_count": 24,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.body(f\"hand1_distal_phalanx_ii\").xquat, data.body(f\"hand1_middle_phalanx_ii\").xquat"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 25,
+   "id": "f2427246-d1bd-4561-bae6-15ab4b419fa9",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "array([-0.07430379,  0.38115375, -0.03662901, -0.01000088])"
+      ]
+     },
+     "execution_count": 25,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.body(f\"hand1_distal_phalanx_ii\").xquat - data.body(f\"hand1_middle_phalanx_ii\").xquat"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 39,
+   "id": "f548df05-3517-407f-aa7c-2c54eba25c10",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "59.999999999999986"
+      ]
+     },
+     "execution_count": 39,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "dp = data.body(f\"hand1_distal_phalanx_ii\").xquat\n",
+    "mp = data.body(f\"hand1_middle_phalanx_ii\").xquat\n",
+    "np.degrees(2*np.arccos(np.abs(np.dot(dp, mp))))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "id": "d0ac27d8-3e7e-469a-affd-bfb54ca5f6b3",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import numpy as np\n",
+    "\n",
+    "quat1 = [[ 0.92094275,  0.37735207,  0.0068244 , -0.09707367], \n",
+    "         [ 0.92094275,  0.37735207,  0.0068244 , -0.09707367]]\n",
+    "\n",
+    "quat2 = [[ 0.99524654, -0.00380168,  0.0434534 , -0.08707279],\n",
+    "        [ 0.99524654, -0.00380168,  0.0434534 , -0.08707279]]\n",
+    "\n",
+    "# quat1 = [ 0.92094275,  0.37735207,  0.0068244 , -0.09707367]\n",
+    "# quat2 = [ 0.99524654, -0.00380168,  0.0434534 , -0.08707279]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 21,
+   "id": "cab6d156-997c-4786-9b45-0e9c5d80882d",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "array([45.00000006, 45.00000006])"
+      ]
+     },
+     "execution_count": 21,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "np.degrees(2*np.arccos(np.abs(np.dot(quat1, np.transpose(quat2)).diagonal())))\n",
+    "# np.arccos(np.abs(np.dot(quat1, np.transpose(quat2)).diagonal()))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "id": "4ab32645-0314-49a7-ac9f-b1a4e850e613",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "numpy.ndarray"
+      ]
+     },
+     "execution_count": 11,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "type(data.site(\"hand1_fingertip_i\").xpos)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 1,
    "id": "aa2a41f5-4edc-41fb-993b-052a4ef81403",
    "metadata": {
     "tags": []
@@ -88,7 +1167,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 3,
+   "execution_count": 2,
    "id": "f5fb5599-1dba-4dea-9a11-8bbcfc2182cf",
    "metadata": {
     "tags": []
@@ -117,7 +1196,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 6,
+   "execution_count": 3,
    "id": "fb37c133-66a6-463f-a841-71c788876593",
    "metadata": {
     "tags": []
@@ -142,7 +1221,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 8,
+   "execution_count": 4,
    "id": "9171da54-7dfb-45c2-942c-31dfef485876",
    "metadata": {
     "tags": []
@@ -154,7 +1233,7 @@
        "5"
       ]
      },
-     "execution_count": 8,
+     "execution_count": 4,
      "metadata": {},
      "output_type": "execute_result"
     }
@@ -165,7 +1244,145 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 10,
+   "execution_count": 16,
+   "id": "f44a77bf-19c6-42a3-b70e-07e60f7d5ef4",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [],
+   "source": [
+    "import time\n",
+    "from IPython.display import display\n",
+    "from IPython.display import clear_output\n",
+    "\n",
+    "for i in range(len(frames)):\n",
+    "    media.show_image(frames[i])\n",
+    "    time.sleep(1)\n",
+    "    clear_output()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "id": "ffc97583-fabb-4d8a-89d2-f3c506653920",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Collecting package metadata (current_repodata.json): done\n",
+      "Solving environment: done\n",
+      "\n",
+      "\n",
+      "==> WARNING: A newer version of conda exists. <==\n",
+      "  current version: 22.11.1\n",
+      "  latest version: 23.1.0\n",
+      "\n",
+      "Please update conda by running\n",
+      "\n",
+      "    $ conda update -n base -c defaults conda\n",
+      "\n",
+      "Or to minimize the number of packages updated during conda update use\n",
+      "\n",
+      "     conda install conda=23.1.0\n",
+      "\n",
+      "\n",
+      "\n",
+      "## Package Plan ##\n",
+      "\n",
+      "  environment location: /opt/conda\n",
+      "\n",
+      "  added / updated specs:\n",
+      "    - ffmpeg\n",
+      "\n",
+      "\n",
+      "The following packages will be downloaded:\n",
+      "\n",
+      "    package                    |            build\n",
+      "    ---------------------------|-----------------\n",
+      "    ca-certificates-2022.12.7  |       ha878542_0         143 KB  conda-forge\n",
+      "    certifi-2022.12.7          |     pyhd8ed1ab_0         147 KB  conda-forge\n",
+      "    conda-23.1.0               |  py310hff52083_0         918 KB  conda-forge\n",
+      "    openssl-1.1.1t             |       h7f8727e_0         3.7 MB\n",
+      "    python_abi-3.10            |          2_cp310           4 KB  conda-forge\n",
+      "    ------------------------------------------------------------\n",
+      "                                           Total:         4.9 MB\n",
+      "\n",
+      "The following NEW packages will be INSTALLED:\n",
+      "\n",
+      "  python_abi         conda-forge/linux-64::python_abi-3.10-2_cp310 \n",
+      "\n",
+      "The following packages will be UPDATED:\n",
+      "\n",
+      "  ca-certificates    pkgs/main::ca-certificates-2022.10.11~ --> conda-forge::ca-certificates-2022.12.7-ha878542_0 \n",
+      "  certifi            pkgs/main/linux-64::certifi-2022.9.24~ --> conda-forge/noarch::certifi-2022.12.7-pyhd8ed1ab_0 \n",
+      "  conda              pkgs/main::conda-22.11.1-py310h06a430~ --> conda-forge::conda-23.1.0-py310hff52083_0 \n",
+      "  openssl                                 1.1.1s-h7f8727e_0 --> 1.1.1t-h7f8727e_0 \n",
+      "\n",
+      "\n",
+      "\n",
+      "Downloading and Extracting Packages\n",
+      "conda-23.1.0         | 918 KB    |                                       |   0% \n",
+      "certifi-2022.12.7    | 147 KB    |                                       |   0% \u001b[A\n",
+      "\n",
+      "python_abi-3.10      | 4 KB      |                                       |   0% \u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "ca-certificates-2022 | 143 KB    |                                       |   0% \u001b[A\u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "\n",
+      "openssl-1.1.1t       | 3.7 MB    |                                       |   0% \u001b[A\u001b[A\u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "ca-certificates-2022 | 143 KB    | ####1                                 |  11% \u001b[A\u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "\n",
+      "openssl-1.1.1t       | 3.7 MB    | 4                                     |   1% \u001b[A\u001b[A\u001b[A\u001b[A\n",
+      "conda-23.1.0         | 918 KB    | 6                                     |   2% \u001b[A\n",
+      "\n",
+      "python_abi-3.10      | 4 KB      | ##################################### | 100% \u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "ca-certificates-2022 | 143 KB    | ##################################### | 100% \u001b[A\u001b[A\u001b[A\n",
+      "certifi-2022.12.7    | 147 KB    | ##################################### | 100% \u001b[A\n",
+      "\n",
+      "\n",
+      "\n",
+      "openssl-1.1.1t       | 3.7 MB    | #########################9            |  70% \u001b[A\u001b[A\u001b[A\u001b[A\n",
+      "\n",
+      "conda-23.1.0         | 918 KB    | ##################################### | 100% \u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "\n",
+      "                                                                                \u001b[A\u001b[A\u001b[A\u001b[A\n",
+      "                                                                                \u001b[A\n",
+      "\n",
+      "                                                                                \u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "                                                                                \u001b[A\u001b[A\u001b[A\n",
+      "\n",
+      "\n",
+      "\n",
+      "                                                                                \u001b[A\u001b[A\u001b[A\u001b[A\n",
+      "Preparing transaction: done\n",
+      "Verifying transaction: done\n",
+      "Executing transaction: done\n"
+     ]
+    }
+   ],
+   "source": [
+    "!conda install -c conda-forge ffmpeg -y"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 12,
    "id": "f0f4a316-1295-456b-9dbe-81bc06d68927",
    "metadata": {
     "tags": []
@@ -173,7 +1390,7 @@
    "outputs": [
     {
      "ename": "RuntimeError",
-     "evalue": "Error writing '/tmp/tmpsdkjwb4w/file.mp4': Unrecognized option 'qp'.\nError splitting the argument list: Option not found\n",
+     "evalue": "Error writing '/tmp/tmpl9eo_73w/file.mp4': Unrecognized option 'qp'.\nError splitting the argument list: Option not found\n",
      "output_type": "error",
      "traceback": [
       "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
@@ -183,14 +1400,14 @@
       "\u001b[0;31mBrokenPipeError\u001b[0m: [Errno 32] Broken pipe",
       "\nDuring handling of the above exception, another exception occurred:\n",
       "\u001b[0;31mRuntimeError\u001b[0m                              Traceback (most recent call last)",
-      "Cell \u001b[0;32mIn[10], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[43mmedia\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mshow_video\u001b[49m\u001b[43m(\u001b[49m\u001b[43mframes\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfps\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m60\u001b[39;49m\u001b[43m)\u001b[49m\n",
+      "Cell \u001b[0;32mIn[12], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m \u001b[43mmedia\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mshow_video\u001b[49m\u001b[43m(\u001b[49m\u001b[43mframes\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfps\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m60\u001b[39;49m\u001b[43m)\u001b[49m\n",
       "File \u001b[0;32m/opt/conda/lib/python3.10/site-packages/mediapy/__init__.py:1772\u001b[0m, in \u001b[0;36mshow_video\u001b[0;34m(images, title, **kwargs)\u001b[0m\n\u001b[1;32m   1749\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mshow_video\u001b[39m(\n\u001b[1;32m   1750\u001b[0m     images: Iterable[_NDArray], \u001b[38;5;241m*\u001b[39m, title: \u001b[38;5;28mstr\u001b[39m \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs: Any\n\u001b[1;32m   1751\u001b[0m ) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28mstr\u001b[39m \u001b[38;5;241m|\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m   1752\u001b[0m \u001b[38;5;250m  \u001b[39m\u001b[38;5;124;03m\"\"\"Displays a video in the IPython notebook and optionally saves it to a file.\u001b[39;00m\n\u001b[1;32m   1753\u001b[0m \n\u001b[1;32m   1754\u001b[0m \u001b[38;5;124;03m  See `show_videos`.\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m   1770\u001b[0m \u001b[38;5;124;03m    html string if `return_html` is `True`.\u001b[39;00m\n\u001b[1;32m   1771\u001b[0m \u001b[38;5;124;03m  \"\"\"\u001b[39;00m\n\u001b[0;32m-> 1772\u001b[0m   \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mshow_videos\u001b[49m\u001b[43m(\u001b[49m\u001b[43m[\u001b[49m\u001b[43mimages\u001b[49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m[\u001b[49m\u001b[43mtitle\u001b[49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n",
       "File \u001b[0;32m/opt/conda/lib/python3.10/site-packages/mediapy/__init__.py:1856\u001b[0m, in \u001b[0;36mshow_videos\u001b[0;34m(videos, titles, width, height, downsample, columns, fps, bps, qp, codec, ylabel, html_class, return_html, **kwargs)\u001b[0m\n\u001b[1;32m   1854\u001b[0m   video \u001b[38;5;241m=\u001b[39m [resize_image(image, (h, w)) \u001b[38;5;28;01mfor\u001b[39;00m image \u001b[38;5;129;01min\u001b[39;00m video]\n\u001b[1;32m   1855\u001b[0m   first_image \u001b[38;5;241m=\u001b[39m video[\u001b[38;5;241m0\u001b[39m]\n\u001b[0;32m-> 1856\u001b[0m data \u001b[38;5;241m=\u001b[39m \u001b[43mcompress_video\u001b[49m\u001b[43m(\u001b[49m\n\u001b[1;32m   1857\u001b[0m \u001b[43m    \u001b[49m\u001b[43mvideo\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmetadata\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mmetadata\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mfps\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mfps\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mbps\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mbps\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mqp\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mqp\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mcodec\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mcodec\u001b[49m\n\u001b[1;32m   1858\u001b[0m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m   1859\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m title \u001b[38;5;129;01mand\u001b[39;00m _config\u001b[38;5;241m.\u001b[39mshow_save_dir:\n\u001b[1;32m   1860\u001b[0m   suffix \u001b[38;5;241m=\u001b[39m _filename_suffix_from_codec(codec)\n",
       "File \u001b[0;32m/opt/conda/lib/python3.10/site-packages/mediapy/__init__.py:1691\u001b[0m, in \u001b[0;36mcompress_video\u001b[0;34m(images, codec, **kwargs)\u001b[0m\n\u001b[1;32m   1689\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m tempfile\u001b[38;5;241m.\u001b[39mTemporaryDirectory() \u001b[38;5;28;01mas\u001b[39;00m directory_name:\n\u001b[1;32m   1690\u001b[0m   tmp_path \u001b[38;5;241m=\u001b[39m pathlib\u001b[38;5;241m.\u001b[39mPath(directory_name) \u001b[38;5;241m/\u001b[39m \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mfile\u001b[39m\u001b[38;5;132;01m{\u001b[39;00msuffix\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m-> 1691\u001b[0m   \u001b[43mwrite_video\u001b[49m\u001b[43m(\u001b[49m\u001b[43mtmp_path\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mimages\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mcodec\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mcodec\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m   1692\u001b[0m   \u001b[38;5;28;01mreturn\u001b[39;00m tmp_path\u001b[38;5;241m.\u001b[39mread_bytes()\n",
       "File \u001b[0;32m/opt/conda/lib/python3.10/site-packages/mediapy/__init__.py:1661\u001b[0m, in \u001b[0;36mwrite_video\u001b[0;34m(path, images, **kwargs)\u001b[0m\n\u001b[1;32m   1659\u001b[0m   dtype \u001b[38;5;241m=\u001b[39m np\u001b[38;5;241m.\u001b[39mdtype(np\u001b[38;5;241m.\u001b[39muint16)\n\u001b[1;32m   1660\u001b[0m kwargs \u001b[38;5;241m=\u001b[39m {\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mmetadata\u001b[39m\u001b[38;5;124m'\u001b[39m: \u001b[38;5;28mgetattr\u001b[39m(images, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mmetadata\u001b[39m\u001b[38;5;124m'\u001b[39m, \u001b[38;5;28;01mNone\u001b[39;00m), \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs}\n\u001b[0;32m-> 1661\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m VideoWriter(path, shape\u001b[38;5;241m=\u001b[39mshape, dtype\u001b[38;5;241m=\u001b[39mdtype, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs) \u001b[38;5;28;01mas\u001b[39;00m writer:\n\u001b[1;32m   1662\u001b[0m   \u001b[38;5;28;01mfor\u001b[39;00m image \u001b[38;5;129;01min\u001b[39;00m images:\n\u001b[1;32m   1663\u001b[0m     writer\u001b[38;5;241m.\u001b[39madd_image(image)\n",
       "File \u001b[0;32m/opt/conda/lib/python3.10/site-packages/mediapy/__init__.py:1534\u001b[0m, in \u001b[0;36mVideoWriter.__exit__\u001b[0;34m(self, *_)\u001b[0m\n\u001b[1;32m   1533\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m__exit__\u001b[39m(\u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39m_: Any) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m-> 1534\u001b[0m   \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mclose\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n",
       "File \u001b[0;32m/opt/conda/lib/python3.10/site-packages/mediapy/__init__.py:1585\u001b[0m, in \u001b[0;36mVideoWriter.close\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1583\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_proc\u001b[38;5;241m.\u001b[39mwait():\n\u001b[1;32m   1584\u001b[0m   s \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_proc\u001b[38;5;241m.\u001b[39mstderr\u001b[38;5;241m.\u001b[39mread()\u001b[38;5;241m.\u001b[39mdecode()\n\u001b[0;32m-> 1585\u001b[0m   \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mRuntimeError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mError writing \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00ms\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m   1586\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_popen\u001b[38;5;241m.\u001b[39m\u001b[38;5;21m__exit__\u001b[39m(\u001b[38;5;28;01mNone\u001b[39;00m, \u001b[38;5;28;01mNone\u001b[39;00m, \u001b[38;5;28;01mNone\u001b[39;00m)\n\u001b[1;32m   1587\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_popen \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m\n",
-      "\u001b[0;31mRuntimeError\u001b[0m: Error writing '/tmp/tmpsdkjwb4w/file.mp4': Unrecognized option 'qp'.\nError splitting the argument list: Option not found\n"
+      "\u001b[0;31mRuntimeError\u001b[0m: Error writing '/tmp/tmpl9eo_73w/file.mp4': Unrecognized option 'qp'.\nError splitting the argument list: Option not found\n"
      ]
     }
    ],
@@ -209,7 +1426,7 @@
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "Python 3",
    "language": "python",
    "name": "python3"
   },
@@ -223,7 +1440,7 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.10.8"
+   "version": "3.8.12"
   }
  },
  "nbformat": 4,
diff --git a/darm_training/sb3_sac_darm_sf_hand-nb3.ipynb b/darm_training/sb3_sac_darm_sf_hand-nb3.ipynb
index 649aa15..c635da7 100644
--- a/darm_training/sb3_sac_darm_sf_hand-nb3.ipynb
+++ b/darm_training/sb3_sac_darm_sf_hand-nb3.ipynb
@@ -4899,7 +4899,7 @@
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "Python 3",
    "language": "python",
    "name": "python3"
   },
@@ -4913,7 +4913,7 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.10.8"
+   "version": "3.8.12"
   },
   "vscode": {
    "interpreter": {
diff --git a/darm_training/tutorial.ipynb b/darm_training/tutorial.ipynb
index d0c63a4..e8ed313 100644
--- a/darm_training/tutorial.ipynb
+++ b/darm_training/tutorial.ipynb
@@ -2235,7 +2235,7 @@
   },
   "gpuClass": "premium",
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "Python 3",
    "language": "python",
    "name": "python3"
   },
@@ -2249,7 +2249,7 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.10.8"
+   "version": "3.8.12"
   }
  },
  "nbformat": 4,
diff --git a/darm_training/viz_model_darm_hand.ipynb b/darm_training/viz_model_darm_hand.ipynb
index 9ea0713..6a97363 100644
--- a/darm_training/viz_model_darm_hand.ipynb
+++ b/darm_training/viz_model_darm_hand.ipynb
@@ -17,7 +17,7 @@
   },
   {
    "cell_type": "code",
-   "execution_count": 7,
+   "execution_count": 6,
    "id": "e5eed09e-b075-4a0c-a066-0143b39af216",
    "metadata": {
     "tags": []
@@ -38,6 +38,8 @@
    "outputs": [],
    "source": [
     "import os\n",
+    "import numpy as np\n",
+    "import mujoco as mujoco\n",
     "DARM_XML_FILE = f\"{os.getenv('DARM_MUJOCO_PATH')}/mujoco_env/darm.xml\"\n",
     "xml_path = DARM_XML_FILE\n",
     "\n",
@@ -46,18 +48,702 @@
     "renderer = mujoco.Renderer(model)"
    ]
   },
+  {
+   "cell_type": "markdown",
+   "id": "c281715b-5045-41b5-8c95-0b576a3195c1",
+   "metadata": {},
+   "source": [
+    "#### DARMEnv"
+   ]
+  },
   {
    "cell_type": "code",
-   "execution_count": 4,
-   "id": "89589b6d-aa85-49fe-a52d-c02b7bf81853",
+   "execution_count": 3,
+   "id": "73d7568e-dee2-451b-839a-e0844a773ae5",
    "metadata": {
     "tags": []
    },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Loaded XML file successfully\n"
+     ]
+    }
+   ],
+   "source": [
+    "import gym\n",
+    "from darm_gym_env import DARMEnv\n",
+    "\n",
+    "env = gym.make(\"darm/DarmHand-v0\", render_mode=None, hand_name=\"hand1\",\n",
+    "               single_finger_env=False)\n",
+    "obs = env.reset()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 7,
+   "id": "86d73499-0155-4ae7-b6e7-690c49dc3f03",
+   "metadata": {},
    "outputs": [
     {
      "data": {
       "text/html": [
-       "<table class=\"show_images\" style=\"border-spacing:0px;\"><tr><td style=\"padding:1px;\"><img width=\"320\" height=\"240\" style=\"image-rendering:auto; object-fit:cover;\" src=\"data:image/png;base64,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\"/></td></tr></table>"
+       "<table class=\"show_images\" style=\"border-spacing:0px;\"><tr><td style=\"padding:1px;\"><img width=\"320\" height=\"240\" style=\"image-rendering:auto; object-fit:cover;\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAADwCAIAAAD+Tyo8AAAA9UlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPBohR0AAXbPpmUAAAAASUVORK5CYII=\"/></td></tr></table>"
+      ],
+      "text/plain": [
+       "<IPython.core.display.HTML object>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    }
+   ],
+   "source": [
+    "media.show_image(env.render())"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "5c58466f-c665-4e13-869b-5c0278edc143",
+   "metadata": {},
+   "source": [
+    "#### End of DARMEnv"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 81,
+   "id": "125b27cf-27e0-436e-8ef5-6d4693c76ac2",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [],
+   "source": [
+    "fingertip_obs[:, :3], self.target_obs[:, :3]import gym\n",
+    "import mujoco as mj\n",
+    "class MjModel(gym.Env):\n",
+    "    metadata = {\"render_modes\": [\"human\"], \"render_fps\": 60}\n",
+    "\n",
+    "    def __init__(self, render_mode=None, action_time=0.08, hand_name=\"hand1\",\n",
+    "                min_th = 0.004,\n",
+    "                min_target_th = 2*0.004,\n",
+    "                max_target_th = 5*0.004, # 20 mm\n",
+    "                target_joint_state_delta = [],\n",
+    "                min_joint_vals = [],\n",
+    "                max_joint_vals = [],\n",
+    "                max_tendon_tension = [],\n",
+    "                single_finger_env = False,\n",
+    "                ignore_load_start_states = True,\n",
+    "                digits = [\"ii\"]\n",
+    "                ) -> None:\n",
+    "        super().__init__()\n",
+    "        assert render_mode is None or render_mode in self.metadata[\"render_modes\"]\n",
+    "        \n",
+    "\n",
+    "        # ========================== Env Parameters ==========================\n",
+    "        self.render_mode = render_mode\n",
+    "        self.hand_name = hand_name\n",
+    "        self.single_finger_env = single_finger_env\n",
+    "        self.action_time = action_time\n",
+    "        self.ep_start_time = 0  # episode start time\n",
+    "\n",
+    "\n",
+    "        # ========================== Load the Model ==========================\n",
+    "        self._load_model()\n",
+    "        self.model = model\n",
+    "        self.data = data\n",
+    "        if not (self.model and self.data):\n",
+    "            raise \"Error loading model\"\n",
+    "        self._get_fingertip_indices()\n",
+    "        \n",
+    "\n",
+    "        # ========================== Setup Rendering ==========================\n",
+    "        self.renderer = mj.Renderer(self.model)\n",
+    "        # enable joint visualization option:\n",
+    "        self.scene_option = mj.MjvOption()\n",
+    "        self.scene_option.flags[mj.mjtVisFlag.mjVIS_JOINT] = True\n",
+    "        self.last_frame = self.renderer.render()\n",
+    "        self.last_frame_time = 0\n",
+    "\n",
+    "\n",
+    "        # ========================== Load targets ==========================\n",
+    "        if not ignore_load_start_states:\n",
+    "            self._load_start_states()\n",
+    "\n",
+    "\n",
+    "        # ========================== Mujoco Model Simulation Parameters ==========================\n",
+    "        self.min_joint_vals = min_joint_vals or self._get_joint_limits(\"min\")   # degrees\n",
+    "        self.max_joint_vals = max_joint_vals or self._get_joint_limits(\"max\")   # degress\n",
+    "        # abs increament of joint state from starting state to target state\n",
+    "        self.target_joint_state_delta = target_joint_state_delta or self._compute_target_joint_state_delta()   # degrees\n",
+    "        self.max_tendon_tension = max_tendon_tension or self._get_actuator_ctrlrange(\"max\")\n",
+    "\n",
+    "        self.min_joint_vals = self.min_joint_vals*(np.pi/180)\n",
+    "        self.max_joint_vals = self.max_joint_vals*(np.pi/180)\n",
+    "        self.target_joint_state_delta = self.target_joint_state_delta*(np.pi/180)\n",
+    "\n",
+    "        self.min_th = min_th    # norm threshold in metres at which env is solved\n",
+    "        self.min_target_th = min_target_th  # min norm to target state\n",
+    "        self.max_target_th = max_target_th  # max norm to target state\n",
+    "\n",
+    "        # Initialize target observation\n",
+    "        self.target_obs = np.zeros((5,7))\n",
+    "        self.prev_fingertip_pose = np.zeros((5,7))\n",
+    "        \n",
+    "\n",
+    "\n",
+    "        # ========================== Reward Components Weights ==========================\n",
+    "        self.rwd_keys_wt = dict(\n",
+    "            reach = 1.0,\n",
+    "            bonus = 4.0,\n",
+    "            penalty = 50,\n",
+    "            act_reg = 0.01,\n",
+    "            # sparse = 1,\n",
+    "            # solved = 1, # review - weight should not be assigned to this?\n",
+    "            # done = 1 # review - weight should not be assigned to this?\n",
+    "        )\n",
+    "\n",
+    "\n",
+    "        # ========================== Get Ref Position ==========================\n",
+    "        # Reference Position is at the centre of the wrist\n",
+    "        # The ref pos will remain fixed since it was taken before simulation started\n",
+    "        mj.mj_forward(self.model, self.data)\n",
+    "        ref_body_idx = mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_BODY), f\"{self.hand_name}_rc_centre_block\")\n",
+    "        self.ref_pos = np.array(self.data.xpos[ref_body_idx])\n",
+    "\n",
+    "\n",
+    "        # ========================== Define Observation and Action Space ==========================\n",
+    "        self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, \n",
+    "                                                shape=(3*3*len(self.fingertip_indices),), \n",
+    "                                                dtype=np.float32)\n",
+    "        \n",
+    "\n",
+    "        # NOTE: Watch out for Box upper limit if Carpal Actuators are involved\n",
+    "        # FIXME: Fix action range in reward and step functions. Current ==> [0,2] after denorm\n",
+    "        # Define a mujoco action range array used for scaling\n",
+    "        self.action_space = gym.spaces.Box(low=np.array([-1.0]*self.model.nu), \n",
+    "                                            high=np.array([1.0]*self.model.nu), \n",
+    "                                            shape=(self.model.nu,), dtype=np.float32)\n",
+    "\n",
+    "\n",
+    "        # ========================== For Human Rendering ==========================\n",
+    "        self.window = None\n",
+    "        self.window_size = 1200, 900\n",
+    "\n",
+    "        # ========================== Others ==========================\n",
+    "        self.index_str_mapping = {\"i\":0, \"ii\":1, \"iii\":2, \"iv\":3, \"v\":4}\n",
+    "        self.index_int_mapping = {0:\"i\", 1:\"ii\", 2:\"iii\", 3:\"iv\", 4:\"v\"}\n",
+    "        self.digits = digits\n",
+    "\n",
+    "    def _load_model(self):\n",
+    "        xml_path = DARM_XML_FILE\n",
+    "        self.model = mj.MjModel.from_xml_path(xml_path)\n",
+    "\n",
+    "        if self.model: \n",
+    "            print(\"Loaded XML file successfully\") \n",
+    "        else:\n",
+    "            print(f\"Error Loading XML file: {xml_path}\")\n",
+    "            return\n",
+    "        \n",
+    "        self.data = mj.MjData(self.model)\n",
+    "        renderer = mj.Renderer(self.model)\n",
+    "\n",
+    "    def _load_start_states(self):\n",
+    "        if self.single_finger_env:\n",
+    "            filename = SF_START_STATE_FILE\n",
+    "        else:\n",
+    "            filename = MF_START_STATE_FILE\n",
+    "\n",
+    "        with open(filename, 'rb') as f:\n",
+    "            self.start_states = np.load(f, allow_pickle=True)\n",
+    "            self.start_states_len = len(self.start_states)\n",
+    "\n",
+    "    def _get_joint_limits(self, type = None):\n",
+    "        joint_limits = []\n",
+    "        for i in range(self.model.njnt):\n",
+    "            joint_limits.append(self.model.jnt_range[i]*(180/np.pi))\n",
+    "        \n",
+    "        joint_limits = np.asarray(joint_limits)\n",
+    "        \n",
+    "        if type == \"min\":\n",
+    "            return joint_limits[:, 0]\n",
+    "        if type == \"max\":\n",
+    "            return joint_limits[:, 1]\n",
+    "        \n",
+    "        return joint_limits[:, 0], joint_limits[:, 1]\n",
+    "\n",
+    "    def _compute_target_joint_state_delta(self):\n",
+    "        # return (self.max_joint_vals - self.min_joint_vals)//10  # for every range of 10 deg, have a delta of 1 deg\n",
+    "        joint_state_delta =  ((self.max_joint_vals - self.min_joint_vals)//40) * 2  # for every range of 40 deg, have a delta of 2 deg\n",
+    "        return np.clip(joint_state_delta, a_min=2, a_max=10)    # a minimum delta of 2 degrees, max of 10 degrees\n",
+    "\n",
+    "    def _get_actuator_ctrlrange(self, type = None):\n",
+    "        if type == \"min\":\n",
+    "            return np.array([self.model.actuator_ctrlrange[i][0] for i in range(self.model.nu)])\n",
+    "        if type == \"max\":\n",
+    "            return np.array([self.model.actuator_ctrlrange[i][1] for i in range(self.model.nu)])\n",
+    "    \n",
+    "        ctrl_range = np.array([self.model.actuator_ctrlrange[i] for i in range(self.model.nu)])\n",
+    "        return ctrl_range[:, 0], ctrl_range[:, 1] # (min, max)\n",
+    "\n",
+    "    def _init_controller(self):\n",
+    "        pass\n",
+    "\n",
+    "    def _controller_cb(self, model, data):\n",
+    "        pass\n",
+    "\n",
+    "    def _get_fingertip_indices(self):\n",
+    "        # NOTE: Remember to set the mocap index properly in reset()\n",
+    "        if self.single_finger_env:\n",
+    "            indices = [\"ii\"]\n",
+    "        else:\n",
+    "            indices = [\"i\", \"ii\", \"iii\", \"iv\", \"v\"]\n",
+    "\n",
+    "        self.fingertip_indices = [mj.mj_name2id(self.model, int(mj.mjtObj.mjOBJ_SITE), f\"{self.hand_name}_fingertip_{i}\") for i in indices]\n",
+    "    \n",
+    "    def transform_distance_obs(self, obs):\n",
+    "        \"\"\"\n",
+    "        - Transforms the distance to be in the frame of the wrist (RC Joint)\n",
+    "        - Convert the distance reading to cm\n",
+    "        \"\"\"\n",
+    "        return (obs - self.data.body(f\"{self.hand_name}_rc_centre_block\").xpos)*100\n",
+    "\n",
+    "    def get_finger_frames_pos(self, idx_str):\n",
+    "        # get Proximal Phalanx frame\n",
+    "        def pp_frame():\n",
+    "            # BODY: ${hand_name}_proximal_phalanx_${index}\n",
+    "            frame_pos = self.data.body(f\"{self.hand_name}_proximal_phalanx_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "            \n",
+    "        # get Middle Phalanx frame\n",
+    "        def mp_frame():\n",
+    "            # BODY: ${hand_name}_middle_phalanx_${index} [ii to v]\n",
+    "            frame_pos = self.data.body(f\"{self.hand_name}_middle_phalanx_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "\n",
+    "        # get Distal Phalanx frame\n",
+    "        def dp_frame():\n",
+    "            # BODY: ${hand_name}_distal_phalanx_${index}\n",
+    "            frame_pos = self.data.body(f\"{self.hand_name}_distal_phalanx_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "\n",
+    "        # get fingertip frame\n",
+    "        def fingertip_frame():\n",
+    "            # SITE: ${hand_name}_fingertip_${index}\n",
+    "            frame_pos = self.data.site(f\"{self.hand_name}_fingertip_{idx_str}\").xpos\n",
+    "            return self.transform_distance_obs(frame_pos)\n",
+    "\n",
+    "        if idx_str == \"i\":\n",
+    "            return np.concatenate((pp_frame(), dp_frame(),\n",
+    "                                   fingertip_frame()))\n",
+    "        else:\n",
+    "            return np.concatenate((pp_frame(), mp_frame(),\n",
+    "                                   dp_frame(), fingertip_frame()))\n",
+    "\n",
+    "    def get_fingertip_pose(self, idx_str):\n",
+    "        \"\"\"Returns the position and orientation of the fingertip `idx_str`\"\"\"\n",
+    "\n",
+    "        fingertip_pos = self.data.site(f\"{self.hand_name}_fingertip_{idx_str}\").xpos\n",
+    "        fingertip_pos = self.transform_distance_obs(fingertip_pos)\n",
+    "\n",
+    "        fingertip_orient = self.data.body(f\"{self.hand_name}_distal_phalanx_{idx_str}\").xquat\n",
+    "\n",
+    "        return np.concatenate((fingertip_pos, fingertip_orient))        \n",
+    "\n",
+    "    def get_finger_contacts(self, index):\n",
+    "        contact_geoms1 = self.data.contact.geom1\n",
+    "        contact_geoms2 = self.data.contact.geom2\n",
+    "\n",
+    "        colliding_digits = []\n",
+    "        colliding_with_palm = False\n",
+    "\n",
+    "        def get_digit_str(name):\n",
+    "            if name.endswith(\"_i\"): return \"i\"\n",
+    "            if name.endswith(\"_ii\"): return \"ii\"\n",
+    "            if name.endswith(\"_iii\"): return \"iii\"\n",
+    "            if name.endswith(\"_iv\"): return \"iv\"\n",
+    "            if name.endswith(\"_v\"): return \"v\"\n",
+    "            \n",
+    "            return None\n",
+    "\n",
+    "        def filter_contacts(contacts1, contacts2):\n",
+    "            for idx in range(len(contacts1)):\n",
+    "                geom_idx = contacts1[idx]\n",
+    "                # Ignore Wraps\n",
+    "                if \"_wrap\" in self.model.geom(geom_idx).name:\n",
+    "                    continue\n",
+    "                \n",
+    "                # Get the Body name\n",
+    "                bodyid = self.model.geom(geom_idx).bodyid[0]\n",
+    "                bodyname = self.model.body(bodyid).name\n",
+    "\n",
+    "                # If body is in current phalanges group\n",
+    "                if bodyname.endswith(f\"_phalanx_{self.index_int_mapping[index]}\"):\n",
+    "                    coll_geom_idx = contacts2[idx]\n",
+    "                    # Ignore Wraps\n",
+    "                    if \"_wrap\" in self.model.geom(coll_geom_idx).name:\n",
+    "                        continue\n",
+    "\n",
+    "                    # Get the body collided with\n",
+    "                    coll_bodyid = self.model.geom(coll_geom_idx).bodyid[0]\n",
+    "                    coll_bodyname = self.model.body(coll_bodyid).name\n",
+    "\n",
+    "                    if coll_bodyname == \"hand1_carpals_metacarpals\":\n",
+    "                        nonlocal colliding_with_palm\n",
+    "                        colliding_with_palm = True\n",
+    "\n",
+    "                    digit = get_digit_str(coll_bodyname)\n",
+    "                    if digit and (digit != self.index_int_mapping[index]):\n",
+    "                        colliding_digits.append(digit)\n",
+    "\n",
+    "        filter_contacts(contact_geoms1, contact_geoms2)\n",
+    "        filter_contacts(contact_geoms2, contact_geoms1)\n",
+    "\n",
+    "        collision_obs = np.zeros(6)\n",
+    "        if colliding_with_palm: collision_obs[0] = 1\n",
+    "        for idx_str in colliding_digits:\n",
+    "            collision_obs[self.index_str_mapping[idx_str]+1] = 1\n",
+    "\n",
+    "        return collision_obs\n",
+    "\n",
+    "    def digits_in_contact(self):\n",
+    "        indices = [self.index_str_mapping[i] for i in [\"i\", \"ii\", \"iii\", \"iv\", \"v\"]]\n",
+    "        contacts = np.concatenate([self.get_finger_contacts(index) for index in indices])\n",
+    "        return sum(contacts) > 0\n",
+    "\n",
+    "    def get_obs(self, action_time=None):\n",
+    "        def get_target_pose(index):\n",
+    "            return self.target_obs[index]\n",
+    "\n",
+    "        def get_kinematic_chain_obs(index):\n",
+    "            return self.get_finger_frames_pos(self.index_int_mapping[index])\n",
+    "\n",
+    "        def get_vel_obs(index):\n",
+    "            if not action_time:\n",
+    "                # if no action time, velocity is zero. i.e. after reset\n",
+    "                return np.zeros(3)\n",
+    "            \n",
+    "            prev_fingertip_pos = self.prev_fingertip_pose[index][:3]\n",
+    "            new_fingertip_pos = self.get_fingertip_pose(self.index_int_mapping[index])[:3]\n",
+    "            vel_obs = (new_fingertip_pos - prev_fingertip_pos)/action_time\n",
+    "            return vel_obs\n",
+    "\n",
+    "        def get_contact_obs(index):\n",
+    "            return self.get_finger_contacts(index)\n",
+    "\n",
+    "        def get_finger_obs(index):\n",
+    "            return np.concatenate((get_target_pose(index),\n",
+    "                            get_kinematic_chain_obs(index),\n",
+    "                            get_vel_obs(index),\n",
+    "                            get_contact_obs(index)))\n",
+    "            \n",
+    "        indices = [self.index_str_mapping[i] for i in self.digits]\n",
+    "        obs = np.concatenate([get_finger_obs(index) for index in indices])\n",
+    "        return obs\n",
+    "\n",
+    "    def _get_info(self):\n",
+    "        return {\"sim_time\": self.data.time - self.ep_start_time}\n",
+    "\n",
+    "    def _norm_to_target(self, obs):\n",
+    "        \"\"\"\n",
+    "        Returns the norm of each fingertip to the target position\n",
+    "        obs: an observation from the observation space [...fingertip_pos, ...target_pos, ...fingertip_vel]\n",
+    "        \"\"\"\n",
+    "        obs = obs.reshape((-1, 3))\n",
+    "        n_fingertips = len(self.fingertip_indices)\n",
+    "\n",
+    "        fingertip_poses = obs[0:n_fingertips]\n",
+    "        target_poses = obs[n_fingertips:2*n_fingertips]\n",
+    "\n",
+    "        return np.linalg.norm(fingertip_poses-target_poses, ord=2, axis=-1)\n",
+    "\n",
+    "    def _get_reward(self, action, new_state):\n",
+    "        \"\"\"\n",
+    "        Reward function to compute reward given action, and new state.\n",
+    "        R = R(a, S')\n",
+    "\n",
+    "        Agent is punished for being far from target\n",
+    "        Agent is punished for going farther than a threshold from the target\n",
+    "        Agent is punished for high action magnitude\n",
+    "        Agent is rewarded for being close to the target\n",
+    "        Agent is rewarded for coming close to the target beyond a threshold \n",
+    "        \"\"\"\n",
+    "\n",
+    "        reach_dist = self._norm_to_target(new_state)    # NOTE: Single finger\n",
+    "        near_th = self.min_th\n",
+    "        far_th = 2*self.max_target_th\n",
+    "\n",
+    "        # Scale action down to [0, 1] from [0, max_tendon_tension]\n",
+    "        action = action / self.max_tendon_tension\n",
+    "        \n",
+    "        # NOTE: Some of the fingers in five fingered hand have more than five actuators\n",
+    "        # act_mag = np.linalg.norm(action.reshape(-1, 5)) # reshape action to (-1,5), ensure nu is ordered from mujoco\n",
+    "        # TODO: Consider scaling down this act_mag to be equiv. to a single finger with nu=5\n",
+    "        act_mag = np.linalg.norm(action)/np.sqrt(self.model.nu/1) # action magnitude is not measured per finger but as a whole\n",
+    "        act_mag = np.array([act_mag]*len(self.fingertip_indices))\n",
+    "        # by dividing by sqrt(nu/5), the norm is similar to when computing with nu==5. Check it out.\n",
+    "        # by dividing by sqrt(nu) act_mag will have a max value in the order of the max_value of action now => 1\n",
+    "        \n",
+    "        rwd_dict = collections.OrderedDict((\n",
+    "            # Optional Keys\n",
+    "            ('reach',   -1.*reach_dist),\n",
+    "            ('bonus',   1.*(reach_dist<2*near_th) + 1.*(reach_dist<near_th)),\n",
+    "            ('act_reg', -1.*act_mag),\n",
+    "            ('penalty', -1.*(reach_dist>far_th)),\n",
+    "            # Must keys\n",
+    "            ('sparse',  -1.*reach_dist),\n",
+    "            ('solved',  reach_dist<near_th),\n",
+    "            ('done',    reach_dist > far_th),\n",
+    "        ))\n",
+    "\n",
+    "            # Weights:\n",
+    "            # reach = 1.0,\n",
+    "            # bonus = 4.0,\n",
+    "            # penalty = 50,\n",
+    "            # act_reg = 0.1,\n",
+    "        rwd_dict['dense'] = np.sum([wt*rwd_dict[key] for key, wt in self.rwd_keys_wt.items()], axis=0)\n",
+    "        return rwd_dict\n",
+    "\n",
+    "    def _get_done(self, new_state):\n",
+    "        return all(self._norm_to_target(new_state) < self.min_th)\n",
+    "\n",
+    "    def _check_collision(self):\n",
+    "        \"\"\"Returns True if there is collision, otherwise False\"\"\"\n",
+    "        return len(self.data.contact.geom1) > 0\n",
+    "\n",
+    "    def generate_start_state(self):\n",
+    "        while True:\n",
+    "            # ========================== Sample valid start_state from Joint Space ==========================\n",
+    "            joint_state = np.random.uniform(low=self.min_joint_vals, high=self.max_joint_vals)\n",
+    "            # normal_sampling = np.random.normal(loc=0.5, scale=0.5/3, size=self.min_joint_vals.shape)\n",
+    "            # normal_sampling = np.clip(normal_sampling, 0, 1)\n",
+    "            # joint_state = self.min_joint_vals + normal_sampling*(self.max_joint_vals - self.min_joint_vals)\n",
+    "            self.forward(joint_state)\n",
+    "\n",
+    "            if self._check_collision(): # returns True if there is collision\n",
+    "                # ensure there is no collision at the start state\n",
+    "                continue\n",
+    "            \n",
+    "        \n",
+    "            # ========================== Create a valid target ==========================\n",
+    "            joint_state_delta = self.target_joint_state_delta*np.random.choice(a=[-1,1], size=(self.model.njnt,), replace=True)\n",
+    "            target_joint_state = np.clip(a=joint_state + joint_state_delta, \n",
+    "                                        a_min=self.min_joint_vals, \n",
+    "                                        a_max=self.max_joint_vals)\n",
+    "            self.target_obs = self.forward(target_joint_state)[:3*len(self.fingertip_indices)]\n",
+    "            if self._check_collision(): # returns True if there is collision\n",
+    "                # ensure there is no collision at the target state\n",
+    "                continue\n",
+    "            \n",
+    "            # Return to start state\n",
+    "            observation = self.forward(joint_state)\n",
+    "\n",
+    "            # Verify distance of start state to target state is within limits\n",
+    "            norm = self._norm_to_target(observation)\n",
+    "            if not (all(norm >= self.min_target_th) and all(norm <= self.max_target_th)):\n",
+    "                continue\n",
+    "            \n",
+    "            # If all checks are positive, break random search loop\n",
+    "            return observation, joint_state, self.target_obs      \n",
+    "\n",
+    "    def sample_saved_start_states(self):\n",
+    "        # Sample a start state from saved start states\n",
+    "        # start_state = [joint_state, target_obs]\n",
+    "        start_state = self.start_states[np.random.randint(self.start_states_len)]\n",
+    "\n",
+    "        # Set Target Obs\n",
+    "        self.target_obs = start_state[1]\n",
+    "\n",
+    "        # Go forward to start state\n",
+    "        observation = self.forward(start_state[0])\n",
+    "\n",
+    "        # Return Observation\n",
+    "        return observation\n",
+    "\n",
+    "    def reset(self, **kwargs):\n",
+    "        # ========================== Get a random valid pose and target ==========================\n",
+    "        # observation, _, _ = self.generate_start_state()\n",
+    "        observation = self.sample_saved_start_states()\n",
+    "\n",
+    "        # ========================== Render Frame ==========================\n",
+    "        if self.render_mode == \"human\":\n",
+    "            # Update target visualization mocaps pos\n",
+    "            self.data.mocap_pos = self.target_obs.reshape(len(self.fingertip_indices),3) + self.ref_pos\n",
+    "            # Go Forward\n",
+    "            mj.mj_forward(self.model, self.data)\n",
+    "            self._render_frame()\n",
+    "\n",
+    "        self.ep_start_time = self.data.time\n",
+    "        return observation\n",
+    "\n",
+    "    def step(self, action):\n",
+    "        prev_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)\n",
+    "\n",
+    "        # action from model is in the range [-1,1]\n",
+    "        # action + 1 === [0, 2]\n",
+    "        # action * x === [0, 2x]\n",
+    "        action = (action + 1)*(self.max_tendon_tension/2)\n",
+    "        action = np.clip(action, 0, self.max_tendon_tension)\n",
+    "        self.data.ctrl[0 : self.model.nu] = action\n",
+    "        time_prev = self.data.time   # simulation time in seconds\n",
+    "\n",
+    "        # Perform action  \n",
+    "        while (self.data.time - time_prev < self.action_time):\n",
+    "            mj.mj_step(self.model, self.data)\n",
+    "        time_after = self.data.time # time after performing action\n",
+    "\n",
+    "\n",
+    "        # Get new observation (fingertips_pos)\n",
+    "        new_obs = self._get_obs(prev_obs=None, new_obs=None, action_time=None)\n",
+    "        # include velocity in new obs\n",
+    "        new_obs = self._get_obs(prev_obs=prev_obs,\n",
+    "                                new_obs=new_obs, \n",
+    "                                action_time=time_after-time_prev)\n",
+    "\n",
+    "        if self.render_mode == \"human\":\n",
+    "            self._render_frame()\n",
+    "\n",
+    "        # Get Reward\n",
+    "        rwd_dict = self._get_reward(action, new_obs)\n",
+    "        reward = rwd_dict[\"dense\"].mean()\n",
+    "        done = any(rwd_dict[\"done\"])  # all(rwd_dict[\"done\"])\n",
+    "        \n",
+    "        return new_obs, reward, done, {**self._get_info(), \"action\": action, \"reward\": {**rwd_dict}}\n",
+    "\n",
+    "    def forward(self, joint_conf):\n",
+    "        self.data.qpos = joint_conf\n",
+    "        mj.mj_forward(self.model, self.data)\n",
+    "        return self._get_obs(prev_obs=None, new_obs=None, action_time=None)\n",
+    "\n",
+    "    def render(self, mode, **kwargs):\n",
+    "        if self.render_mode == \"human\":\n",
+    "            return self._render_frame()\n",
+    "        else:\n",
+    "            T = 1/DARMEnv.metadata[\"render_fps\"]    # period\n",
+    "            if (self.data.time - self.last_frame_time) >= T:\n",
+    "                self.renderer.update_scene(self.data, scene_option=self.scene_option)\n",
+    "                self.last_frame = self.renderer.render()\n",
+    "            return self.last_frame.copy()\n",
+    "\n",
+    "    def _render_frame(self):\n",
+    "        if self.render_mode == \"human\" and not self.window:\n",
+    "            # Init GLFW, create window, make OpenGL context current, request v-sync\n",
+    "            glfw.init()\n",
+    "            self.window = glfw.create_window(self.window_size[0], self.window_size[1], \"DARM\", None, None)\n",
+    "            glfw.make_context_current(self.window)\n",
+    "            glfw.swap_interval(1)\n",
+    "\n",
+    "            # Visualization\n",
+    "            self.cam = mj.MjvCamera()    # abstract camera\n",
+    "            self.opt = mj.MjvOption()    # visualization options\n",
+    "            mj.mjv_defaultCamera(self.cam)\n",
+    "            mj.mjv_defaultOption(self.opt)\n",
+    "            self.scene = mj.MjvScene(self.model, maxgeom=10000)\n",
+    "            self.context = mj.MjrContext(self.model, mj.mjtFontScale.mjFONTSCALE_150.value)\n",
+    "\n",
+    "            self.cam.azimuth = 110\n",
+    "            self.cam.elevation = -24\n",
+    "            self.cam.distance = 0.36\n",
+    "            self.cam.lookat = np.array([0.006, -0.004,  0.215])\n",
+    "\n",
+    "            # For callback functions TODO:\n",
+    "            self.window_button_left = False\n",
+    "            self.window_button_middle = False\n",
+    "            self.window_button_right = False\n",
+    "            self.window_lastx = 0\n",
+    "            self.window_lasty = 0\n",
+    "\n",
+    "            def mouse_button(window, button, act, mods):\n",
+    "                # update button state\n",
+    "                self.window_button_left = (glfw.get_mouse_button(\n",
+    "                    window, glfw.MOUSE_BUTTON_LEFT) == glfw.PRESS)\n",
+    "                self.window_button_middle = (glfw.get_mouse_button(\n",
+    "                    window, glfw.MOUSE_BUTTON_MIDDLE) == glfw.PRESS)\n",
+    "                self.window_button_right = (glfw.get_mouse_button(\n",
+    "                    window, glfw.MOUSE_BUTTON_RIGHT) == glfw.PRESS)\n",
+    "\n",
+    "                # update mouse position\n",
+    "                glfw.get_cursor_pos(window) # TODO: Why is this needed again\n",
+    "\n",
+    "            def mouse_move(window, xpos, ypos):\n",
+    "                # compute mouse displacement, save\n",
+    "                dx = xpos - self.window_lastx\n",
+    "                dy = ypos - self.window_lasty\n",
+    "                self.window_lastx = xpos\n",
+    "                self.window_lasty = ypos\n",
+    "\n",
+    "                # no buttons down: nothing to do\n",
+    "                if (not self.window_button_left) and (not self.window_button_middle) and (not self.window_button_right):\n",
+    "                    return\n",
+    "\n",
+    "                # get current window size\n",
+    "                width, height = glfw.get_window_size(window)\n",
+    "\n",
+    "                # get shift key state\n",
+    "                PRESS_LEFT_SHIFT = glfw.get_key(\n",
+    "                    window, glfw.KEY_LEFT_SHIFT) == glfw.PRESS\n",
+    "                PRESS_RIGHT_SHIFT = glfw.get_key(\n",
+    "                    window, glfw.KEY_RIGHT_SHIFT) == glfw.PRESS\n",
+    "                mod_shift = (PRESS_LEFT_SHIFT or PRESS_RIGHT_SHIFT)\n",
+    "\n",
+    "                # determine action based on mouse button\n",
+    "                if self.window_button_right:\n",
+    "                    if mod_shift:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_MOVE_H\n",
+    "                    else:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_MOVE_V\n",
+    "                elif self.window_button_left:\n",
+    "                    if mod_shift:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_ROTATE_H\n",
+    "                    else:\n",
+    "                        action = mj.mjtMouse.mjMOUSE_ROTATE_V\n",
+    "                else:\n",
+    "                    action = mj.mjtMouse.mjMOUSE_ZOOM\n",
+    "\n",
+    "                mj.mjv_moveCamera(self.model, action, dx/width,\n",
+    "                                dy/height, self.scene, self.cam)    # TODO: Look into this, height/width issue\n",
+    "\n",
+    "            def scroll(window, xoffset, yoffset):\n",
+    "                action = mj.mjtMouse.mjMOUSE_ZOOM\n",
+    "                mj.mjv_moveCamera(self.model, action, 0.0, -0.05 *\n",
+    "                                yoffset, self.scene, self.cam)\n",
+    "\n",
+    "            glfw.set_cursor_pos_callback(self.window, mouse_move)\n",
+    "            glfw.set_mouse_button_callback(self.window, mouse_button)\n",
+    "            glfw.set_scroll_callback(self.window, scroll)\n",
+    "        \n",
+    "        # Get Framebuffer Viewport\n",
+    "        vp_width, vp_height = glfw.get_framebuffer_size(self.window)\n",
+    "        viewport = mj.MjrRect(0, 0, vp_width, vp_height)\n",
+    "\n",
+    "        # Update scene and render\n",
+    "        mj.mjv_updateScene(self.model, self.data, self.opt, None, self.cam, mj.mjtCatBit.mjCAT_ALL.value, self.scene)\n",
+    "        mj.mjr_render(viewport, self.scene, self.context)\n",
+    "\n",
+    "        # swap OpenGL buffers (blocking call due to v-sync)\n",
+    "        glfw.swap_buffers(self.window)\n",
+    "\n",
+    "        # process pending GUI events, call GLFW callbacks\n",
+    "        glfw.poll_events()\n",
+    "\n",
+    "    def close(self):\n",
+    "        glfw.terminate()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 76,
+   "id": "c1febf74-416a-42e0-b1c2-b5afd3a53d65",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<table class=\"show_images\" style=\"border-spacing:0px;\"><tr><td style=\"padding:1px;\"><img width=\"320\" height=\"240\" style=\"image-rendering:auto; object-fit:cover;\" src=\"data:image/png;base64,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\"/></td></tr></table>"
       ],
       "text/plain": [
        "<IPython.core.display.HTML object>"
@@ -74,6 +760,398 @@
     "media.show_image(renderer.render())"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": 84,
+   "id": "8b3a7994-f031-4945-a3a6-5b6a46e07c99",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Loaded XML file successfully\n"
+     ]
+    },
+    {
+     "data": {
+      "text/plain": [
+       "array([1., 0., 1., 0., 1., 0.])"
+      ]
+     },
+     "execution_count": 84,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "model_cl = MjModel()\n",
+    "model_cl.get_finger_contacts(0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 85,
+   "id": "ea70c616-4b55-4914-9fa8-4aa73a681096",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "True"
+      ]
+     },
+     "execution_count": 85,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "model_cl.digits_in_contact()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 74,
+   "id": "7a92564c-6abf-4898-b179-cb79d4055fc2",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(28,\n",
+       " array([  0.        ,   0.        ,   0.        ,   0.        ,\n",
+       "          0.        ,   0.        ,   0.        ,   2.93      ,\n",
+       "          0.87      ,   9.08      ,   3.35532002,   0.87      ,\n",
+       "         13.94143013,   3.58889742,   0.87      ,  16.61123192,\n",
+       "          3.77279603,   0.87      ,  18.71320273,  47.1599504 ,\n",
+       "         10.875     , 233.91503413,   0.        ,   0.        ,\n",
+       "          0.        ,   0.        ,   0.        ,   0.        ]))"
+      ]
+     },
+     "execution_count": 74,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "len(model_cl.get_obs(0.08)), model_cl.get_obs(0.08)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 68,
+   "id": "c0d8a340-7c0e-47bf-a2b5-9e934fbcdab2",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(array([12, 45], dtype=int32), array([47, 26], dtype=int32))"
+      ]
+     },
+     "execution_count": 68,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.contact.geom1, data.contact.geom2"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 49,
+   "id": "361b5cba-33cc-4f3e-9a44-9a872552647b",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<_MjDataGeomViews\n",
+       "  id: 47\n",
+       "  name: ''\n",
+       "  xmat: array([-0.08988067, -0.97442545, -0.20595267,  0.99594543, -0.08715574,\n",
+       "       -0.02228407,  0.00376421, -0.20712052,  0.97830819])\n",
+       "  xpos: array([-0.03139738,  0.00431935,  0.25504528])\n",
+       ">"
+      ]
+     },
+     "execution_count": 49,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.body(47)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 77,
+   "id": "e5179678-ab1b-488e-acb1-c080c08873c8",
+   "metadata": {
+    "collapsed": true,
+    "jupyter": {
+     "outputs_hidden": true
+    },
+    "tags": []
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "world\n",
+      "hand1_fingertip_i_target\n",
+      "hand1_fingertip_ii_target\n",
+      "hand1_fingertip_iii_target\n",
+      "hand1_fingertip_iv_target\n",
+      "hand1_fingertip_v_target\n",
+      "hand1_forearm\n",
+      "hand1_rc_centre_block\n",
+      "hand1_carpals_metacarpals\n",
+      "hand1_mcp_centre_block_ii\n",
+      "hand1_proximal_phalanx_ii\n",
+      "hand1_middle_phalanx_ii\n",
+      "hand1_distal_phalanx_ii\n",
+      "hand1_mcp_centre_block_iii\n",
+      "hand1_proximal_phalanx_iii\n",
+      "hand1_middle_phalanx_iii\n",
+      "hand1_distal_phalanx_iii\n",
+      "hand1_mcp_centre_block_iv\n",
+      "hand1_proximal_phalanx_iv\n",
+      "hand1_middle_phalanx_iv\n",
+      "hand1_distal_phalanx_iv\n",
+      "hand1_proximal_cm_i_centre_block\n",
+      "hand1_distal_cm_i_centre_block\n",
+      "hand1_metacarpal_i\n",
+      "hand1_proximal_phalanx_i\n",
+      "hand1_distal_phalanx_i\n",
+      "hand1_proximal_cm_v_centre_block\n",
+      "hand1_distal_cm_v_centre_block\n",
+      "hand1_metacarpal_v\n",
+      "hand1_mcp_centre_block_v\n",
+      "hand1_proximal_phalanx_v\n",
+      "hand1_middle_phalanx_v\n"
+     ]
+    }
+   ],
+   "source": [
+    "for i in range(32):\n",
+    "    print(model.body(i).name or \"NO NAME\")"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 15,
+   "id": "bf6a30a7-8157-45c5-ad19-c5cd2956f682",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "0 hand1_carpals_metacarpals NO_NAME\n",
+      "1 hand1_carpals_metacarpals hand1_mcp_iv_wrap\n",
+      "2 hand1_distal_phalanx_ii NO_NAME\n",
+      "3 hand1_metacarpal_i hand1_mcp_i_wrap\n",
+      "4 hand1_distal_phalanx_ii NO_NAME\n",
+      "5 hand1_proximal_phalanx_iv NO_NAME\n",
+      "6 hand1_proximal_phalanx_i hand1_ip_i_wrap\n",
+      "7 hand1_proximal_phalanx_iv NO_NAME\n",
+      "8 hand1_metacarpal_v hand1_mcp_v_wrap\n",
+      "9 hand1_middle_phalanx_iv NO_NAME\n",
+      "10 hand1_middle_phalanx_iv hand1_pip_iv_wrap\n"
+     ]
+    }
+   ],
+   "source": [
+    "sn = 0\n",
+    "for idx in data.contact.geom1: #range(53):\n",
+    "    print(sn, model.body(model.geom(idx).bodyid[0]).name, model.geom(idx).name or \"NO_NAME\")\n",
+    "    sn += 1"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 16,
+   "id": "baebb727-2782-4f28-9675-934dd3c0a5e2",
+   "metadata": {
+    "tags": []
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "0 hand1_proximal_phalanx_i NO_NAME\n",
+      "1 hand1_proximal_phalanx_v NO_NAME\n",
+      "2 hand1_metacarpal_i NO_NAME\n",
+      "3 hand1_distal_phalanx_ii NO_NAME\n",
+      "4 hand1_proximal_phalanx_i NO_NAME\n",
+      "5 hand1_proximal_phalanx_i NO_NAME\n",
+      "6 hand1_proximal_phalanx_iv NO_NAME\n",
+      "7 hand1_distal_phalanx_i NO_NAME\n",
+      "8 hand1_proximal_phalanx_iv NO_NAME\n",
+      "9 hand1_distal_phalanx_i NO_NAME\n",
+      "10 hand1_distal_phalanx_i NO_NAME\n"
+     ]
+    }
+   ],
+   "source": [
+    "sn = 0\n",
+    "for idx in data.contact.geom2: #range(53):\n",
+    "    print(sn, model.body(model.geom(idx).bodyid[0]).name, model.geom(idx).name or \"NO_NAME\")\n",
+    "    sn += 1"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 75,
+   "id": "06912a81-2b6d-447d-b426-41ae0ff33184",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "data.joint(11).qpos = 0.605 # np.radians(60)\n",
+    "data.joint(16).qpos = -0.349 # np.radians(60)\n",
+    "\n",
+    "data.joint(2).qpos = 0.349\n",
+    "data.joint(3).qpos = 1.57\n",
+    "data.joint(4).qpos = 1.57\n",
+    "data.joint(5).qpos = 1.57"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 24,
+   "id": "35ec58b6-43fb-4d8d-99c6-06b376b8173a",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(array([ 0.92094275,  0.37735207,  0.0068244 , -0.09707367]),\n",
+       " array([ 0.99524654, -0.00380168,  0.0434534 , -0.08707279]))"
+      ]
+     },
+     "execution_count": 24,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.body(f\"hand1_distal_phalanx_ii\").xquat, data.body(f\"hand1_middle_phalanx_ii\").xquat"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 25,
+   "id": "f2427246-d1bd-4561-bae6-15ab4b419fa9",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "array([-0.07430379,  0.38115375, -0.03662901, -0.01000088])"
+      ]
+     },
+     "execution_count": 25,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "data.body(f\"hand1_distal_phalanx_ii\").xquat - data.body(f\"hand1_middle_phalanx_ii\").xquat"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 39,
+   "id": "f548df05-3517-407f-aa7c-2c54eba25c10",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "59.999999999999986"
+      ]
+     },
+     "execution_count": 39,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "dp = data.body(f\"hand1_distal_phalanx_ii\").xquat\n",
+    "mp = data.body(f\"hand1_middle_phalanx_ii\").xquat\n",
+    "np.degrees(2*np.arccos(np.abs(np.dot(dp, mp))))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "id": "d0ac27d8-3e7e-469a-affd-bfb54ca5f6b3",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import numpy as np\n",
+    "\n",
+    "quat1 = [[ 0.92094275,  0.37735207,  0.0068244 , -0.09707367], \n",
+    "         [ 0.92094275,  0.37735207,  0.0068244 , -0.09707367]]\n",
+    "\n",
+    "quat2 = [[ 0.99524654, -0.00380168,  0.0434534 , -0.08707279],\n",
+    "        [ 0.99524654, -0.00380168,  0.0434534 , -0.08707279]]\n",
+    "\n",
+    "# quat1 = [ 0.92094275,  0.37735207,  0.0068244 , -0.09707367]\n",
+    "# quat2 = [ 0.99524654, -0.00380168,  0.0434534 , -0.08707279]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 21,
+   "id": "cab6d156-997c-4786-9b45-0e9c5d80882d",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "array([45.00000006, 45.00000006])"
+      ]
+     },
+     "execution_count": 21,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "np.degrees(2*np.arccos(np.abs(np.dot(quat1, np.transpose(quat2)).diagonal())))\n",
+    "# np.arccos(np.abs(np.dot(quat1, np.transpose(quat2)).diagonal()))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "id": "4ab32645-0314-49a7-ac9f-b1a4e850e613",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "numpy.ndarray"
+      ]
+     },
+     "execution_count": 11,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "type(data.site(\"hand1_fingertip_i\").xpos)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": 1,
@@ -348,7 +1426,7 @@
  ],
  "metadata": {
   "kernelspec": {
-   "display_name": "Python 3 (ipykernel)",
+   "display_name": "Python 3",
    "language": "python",
    "name": "python3"
   },
@@ -362,7 +1440,7 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.10.8"
+   "version": "3.8.12"
   }
  },
  "nbformat": 4,
diff --git a/darm_training/wandb/debug-internal.log b/darm_training/wandb/debug-internal.log
index 30b89d1..eb03485 120000
--- a/darm_training/wandb/debug-internal.log
+++ b/darm_training/wandb/debug-internal.log
@@ -1 +1 @@
-run-20230302_150402-6occ3zcz/logs/debug-internal.log
\ No newline at end of file
+run-20230404_151602-13uv3hcl/logs/debug-internal.log
\ No newline at end of file
diff --git a/darm_training/wandb/debug.log b/darm_training/wandb/debug.log
index 6c373ee..4491a71 120000
--- a/darm_training/wandb/debug.log
+++ b/darm_training/wandb/debug.log
@@ -1 +1 @@
-run-20230302_150402-6occ3zcz/logs/debug.log
\ No newline at end of file
+run-20230404_151602-13uv3hcl/logs/debug.log
\ No newline at end of file
diff --git a/darm_training/wandb/latest-run b/darm_training/wandb/latest-run
index f06bc9e..d6b4c62 120000
--- a/darm_training/wandb/latest-run
+++ b/darm_training/wandb/latest-run
@@ -1 +1 @@
-run-20230302_150402-6occ3zcz
\ No newline at end of file
+run-20230404_151602-13uv3hcl
\ No newline at end of file
diff --git a/dist/darm_gym_env-0.0.1-py3.8.egg b/dist/darm_gym_env-0.0.1-py3.8.egg
index ef5cf3d..e55d447 100644
Binary files a/dist/darm_gym_env-0.0.1-py3.8.egg and b/dist/darm_gym_env-0.0.1-py3.8.egg differ
diff --git a/mujoco_env/.ipynb_checkpoints/anthropomorphism_quantification-checkpoint.ipynb b/mujoco_env/.ipynb_checkpoints/anthropomorphism_quantification-checkpoint.ipynb
new file mode 100644
index 0000000..90bf213
--- /dev/null
+++ b/mujoco_env/.ipynb_checkpoints/anthropomorphism_quantification-checkpoint.ipynb
@@ -0,0 +1,33 @@
+{
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "11b01e3f-ad94-4602-bd6f-2424c0937b02",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "Python 3",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.8.12"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/mujoco_env/anthropomorphism_quantification.ipynb b/mujoco_env/anthropomorphism_quantification.ipynb
new file mode 100644
index 0000000..5df6d5a
--- /dev/null
+++ b/mujoco_env/anthropomorphism_quantification.ipynb
@@ -0,0 +1,61 @@
+{
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "id": "6c703919-1ac6-49ed-a42f-8438e523220f",
+   "metadata": {},
+   "source": [
+    "## Quantifying Anthropomorphism"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "id": "d80d4b28-c953-471f-b89b-700f974ed807",
+   "metadata": {},
+   "source": [
+    "### Measure Hand Breadth and Hand Length"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "id": "520c2e72-c04c-46a4-96a9-52f52e9e9ce2",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import mujoco as mj"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "51d143fc-5c5c-4875-890d-f6fe09340bf0",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "model = mj.from_xm"
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "Python 3",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.8.12"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/mujoco_env/darm_hand.xml b/mujoco_env/darm_hand.xml
index 6eb1391..11e9a35 100644
--- a/mujoco_env/darm_hand.xml
+++ b/mujoco_env/darm_hand.xml
@@ -7,6 +7,7 @@
   <!-- Phalanges -->
   <body mocap="true" name="hand1_fingertip_ii_target" pos="0 0.25 0">
     <geom rgba="0 1 0 1" size="0.004" type="sphere"/>
+    <geom pos="0 0 0.006" rgba="0 1 0 1" size="0.002 0.012" type="cylinder"/>
   </body>
   <body childclass="darm_meshes" euler="0 0 0" name="hand1_forearm" pos="0 0 0.12">
     <geom mesh="forearm_mesh" type="mesh"/>
diff --git a/mujoco_env/darm_hand.xml.xacro b/mujoco_env/darm_hand.xml.xacro
index 3e4eb24..ce26a95 100644
--- a/mujoco_env/darm_hand.xml.xacro
+++ b/mujoco_env/darm_hand.xml.xacro
@@ -243,6 +243,8 @@
     <xacro:macro name="fingertip_target" params="hand_name name rgba:=${fingertip_target_mocap_rgba}">
         <body name="${hand_name}_${name}" pos="0 0.25 0" mocap="true" >
             <geom type="sphere" size="${fingertip_target_mocap_size}" rgba="${rgba}" />
+            <geom type="cylinder" size="${fingertip_target_mocap_size/2} ${3*fingertip_target_mocap_size}" 
+                    pos="0 0 ${1.5*fingertip_target_mocap_size}" rgba="${rgba}" />
         </body>
     </xacro:macro>
     
diff --git a/setup.py b/setup.py
index 1c2cc52..51f3101 100644
--- a/setup.py
+++ b/setup.py
@@ -3,7 +3,7 @@ from setuptools import setup
 setup(
     name="darm_gym_env",
     version="0.0.1",
-    install_requires=["mujoco==2.3.2", "gym==0.21.0"],
+    install_requires=["mujoco==2.3.3", "gym==0.21.0"],
     packages=["darm_gym_env"]
 )
 
diff --git a/training_setup.sh b/training_setup.sh
index d5c2419..f3fe37e 100644
--- a/training_setup.sh
+++ b/training_setup.sh
@@ -1,6 +1,7 @@
 sudo apt update
 sudo apt install build-essential -y
 pip install ray[rllib]==2.2.0
+pip install stable-baselines3[extra]
 pip install wandb
 pip install tensorflow_probability
 python setup.py install
